dup:
eql: "="
gt: ">"
lt: "<"
drop:
zero: "0"
one: "1"
two: "2"
add: "+"
mul: "*"
neg:
sub: "-"
# arithmetic shift left
asl:
# arithmetic shift right
asr:
div: "/"
mod:
# bitwise operations
bitand:
bitor:
bitxor:
bitnot:
# emit one byte as character on stdout
emit:
receive:
to_r: ">r"
r_from: "r>"
# literal word
lit: :private
# literal byte
litb: :private
# literal instruction
oplit: :private
# literal base-relative quotation (short)
blitq: :private
qstart: :private
qend: :private
lstart: :private
lend: :private
# ( cond true false -- true/false )
truefalse: "?"
# call absolute address on stack
scall: "call"
# call absolute address on stack (tail call)
stcall: :private
# used to refer to non-quotation data
ref: :private
swap:
token:
# (cstring -- foundp quot/addr)
find:
# memory bounds
# code + data mem
memstart:
memend:
# dictionary mem
dictstart: :private
dictend: :private
# size of one cell
cellsize: "cell"
# start of instruction codes
instbase:
quit:
stack_show: "st"
parsenum: :private
nop:
# unsafe memory operations
# ( -- data-start data-end mem-start mem-end )
memrange: :private
# (value address -- )
_set: :private
_setbyte: :private
# (address -- value)
_get: :private
_getbyte: :private
# care since it depends heavily on invocation context
pwrite:
# call quotation in code (absolute)
acall: :private
# call quotation in code (relative to base address, short)
bcall: :private
# tail call quotation in code (relative to base address, short)
btcall: :private
# clear parameter stack
clear:
# number of items on stack
psplevel:
