dup:
eql: "="
gt: ">"
lt: "<"
drop:
zero: "0"
one: "1"
two: "2"
add: "+"
mul: "*"
neg:
sub: "-"
emit:
receive:
to_r: ">r"
r_from: "r>"
# literal word
lit: :private
# literal byte
litb: :private
# literal instruction
oplit: :private
# literal base-relative quotation (short)
blitq: :private
name:
qstart: :private
qend: :private
lstart: :private
lend: :private
# ( cond true false -- true/false )
truefalse: "?"
# call absolute address on stack
scall: "call"
# call absolute address on stack (tail call)
stcall: private
# used to refer to non-quotation data
ref: :private
swap:
input_str: '"'
# ( -- cstring )
token:
# (cstring -- foundp quot/addr)
find:
# memory bounds
# code + data mem
memstart: :private
memend: :private
# dictionary mem
dictstart: :private
dictend: :private
# size of one cell
cellsize: "cell"
# start of instruction codes
instbase:
# store_tos: ","
# store_ptr: "_CP"
# name_ptr: "_NP"
quit:
stack_show: "st"
asl: "shift"
div: "/"
mod:
parsenum: :private
nop:
# unsafe memory operations
# ( -- data-start data-end mem-start mem-end )
memrange: :private
# (value address -- )
_set: :private
_setbyte: :private
# (address -- value)
_get: :private
_getbyte: :private
# unsafe memory operations, for peripherals
# (value address -- )
input_list: "{"
input_quot: "["
bitand:
bitor:
bitxor:
bitnot:
# restart current (non-tail-called) quotation, should be used with
# care since it depends heavily on invocation context
# TODO: recurse should very probably be a parse-time only word
# recurse:
pwrite:
# call quotation in code (absolute)
acall: :private
# call quotation in code (relative to base address, short)
bcall: :private
# tail call quotation in code (relative to base address, short)
btcall: private
# clear parameter stack
clear:
# number of items on stack
psplevel:
