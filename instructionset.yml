dup:
eql: "="
drop:
zero: "0"
one: "1"
two: "2"
add: "+"
mul: "*"
neg:
sub: "-"
emit:
receive:
to_r: ">r"
r_from: "r>"
# literal word
lit: :private
# literal byte
litb: :private
# literal instruction
oplit: :private
# literal base-relative quotation (short)
blitq: :private
name:
qstart: :private
qend: :private
lstart: :private
lend: :private
# ( cond true false -- true/false )
truefalse: "?"
# call absolute address on stack
scall: "call"
# call absolute address on stack (tail call)
stcall: private
# used to refer to non-quotation data
ref: :private
swap:
allot:
input_str: '"'
find:
# ( -- token )
token:
store_tos: ","
store_ptr: "_CP"
name_ptr: "_NP"
quit:
stack_show: "st"
asl: "shift"
div: "/"
mod:
parsenum: :private
nop:
# (value address -- )
set:
_setchar: "setc"
# (address -- value)
get:
_getchar: "getc"
input_list: "{"
input_quot: "["
bitand:
bitor:
bitxor:
bitnot:
# restart current (non-tail-called) quotation, should be used with
# care since it depends heavily on invocation context
recurse:
pwrite:
# call quotation in code (absolute)
acall: :private
# call quotation in code (relative to base address, short)
bcall: :private
# tail call quotation in code (relative to base address, short)
btcall: private
# clear parameter stack
clear:
# number of items on stack
snum:
