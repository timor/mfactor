# -*- org-babel-default-header-args:C: ((:noweb . "yes")); -*-
#+TITLE:     MFactor Documentation
#+EMAIL:     timor.dd@googlemail.com
#+DATE:      2015-03-17 Di
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: timestamp:nil h:4 author:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+STARTUP: indent

#+begin_src emacs-lisp :exports none
  (setq org-confirm-babel-evaluate nil)
  (add-hook 'org-src-mode-hook
            (lambda ()
              (setq indent-tabs-mode nil)
              (whitespace-mode)))
  nil
#+end_src

#+RESULTS:

* Introduction
MFactor is a (partial) implementation of the [[http://factorcode.org/][factor language]] for embedded systems.
It consists of two parts:

1. A *host compiler*, written in Ruby, which is used with the [[https://github.com/ruby/rake][Rake]] build system to produce a
   binary image (see [[Host Compiler][Host Compiler]]).

2. A *c implementation of a bytecode vm* which is able to execute such an image. (see [[VM
   Implementation][VM Implementation]])

It is intended to be used with a embedded C development environment, where its sources are
compiled together with the host application.

** Usage Concept
The general idea: First compile .mfactor source files to bytecode image, then compile the
provided c source files together with the host application's source files into the final binary.
#+BEGIN_SRC ditaa :file img/concept.png
  +---------+
  |.mfactor +----+
  |source   |    |
  |files    |    |
  +---------+    |
                 v
        +-----------+       +---------------------+
        | rake task |       |interpreter.c        |
        | "mfactor" |       |{d}                  |
        |           |       +---------------------+
        +-----------+                |             
             |                       v             
             v                +----------------+    +--------------+
   +-----------------+        | regular        |    |c application |
   | bytecode image  |------->| compilation    |<---|{d}           |
   | bytecode.c {d}  |        | using gcc      |    +--------------+
   +-----------------+        +----------------+
                                    |
                                    |
                    +--------+      |
                    |binary  |      |
                    |{d}     |<-----+
                    |        |
                    +--------+
#+END_SRC

#+RESULTS:
[[file:img/concept.png]]

A set of mfactor source files is translated by the host compiler (called through rake task
=mfactor=) into a bytecode image.  This bytecode image is then successively executed by
=interpeter()=, which is the actual VM implementation.

In order to incorporate this into a project, several rake tasks are supplied in [[file:../tasks/mfactor.rake][tasks/mfactor.rake]]

- *mfactor*: the main task, which, when called, generates above code
- *mftest[word name]*: helper task, outputs a graphical representation of a specific word in the =generated= subdir.

** Configuring the Rake Task
The rake file is supposed to be included with rake's =import= facility in the host
application's own Rakefile.

Currently, it is configured via setting global variables in the including rake file.
The following must be set:
- =MFACTOR_SRC_DIR=: Determines the directory where the application's mfactor sources can
  be found.  This should point to the application's mfactor source directory.
- =GENERATOR=: which bytecode backend to use, currently, only =Cortex= is supported
- =START_WORD=: word, which will be executed when starting the vm
- =MFACTOR_ROOT_VOCAB=: The root vocabulary, which is first loaded and loads all
  dependencies.  Must be found in =MFACTOR_SRC_DIR=.
- =MFACTOR_DEPENDING_OBJECTS=: To cause Rake to recompile the whole image, this
  should be set to the object files in the application which depend on the generated
  output. This usually means all files that use any of the words defined in
  =MFACTOR_C_WORDS=, as well as the object file that is built from =src/interpreter.c=

The following are for advanced functionality:
- =MFACTOR_C_WORDS=: Hashtable for exposing word locations in bytecode to C. Format:
  #+BEGIN_SRC ruby
      { "mfactor-word-name" => "NAME_OF_CPP_DEFINE" }
  #+END_SRC
  This can be used to generate preprocessor symbols, which can be passed directly to
  =interpreter()=, for example.
- =FF_MFACTOR=: path to file containing interface definitions to c code (see [[*Making%20Existing%20C%20Functions%20Available][Making
  Existing C Functions Available]])
- =MFACTOR_IMAGE_SECTION=: a string describing the linker section that the bytecode-image
  will pe placed into
- =MFACTOR_DICT_SECTION=: same thing for the generated dictionary

** Generated Output Files
In the application's main directory, a directory =generated= is created during the build
process, where several files are generated:

- =bytecode.c= :: main output from the ByteCodeImage class.
- =bytecode.h= :: consists of defines that =interpreter()= and maybe the user application
     needs to know about
- =image.dump= :: after translation, the ByteCodeImage is written here using [[http://ruby-doc.org/core-2.2.3/Marshal.html][Marshal]].  It
     can be reloaded later in the build process with =ByteCodeImage.deserialize= to
     extract information about the image.

** Making Existing C Functions Available
Special global variable =FF_MFACTOR= can be set to a yaml file for
"importing" existing c functions into the interpreter's namespace (Foreign function interface).
entries are in the form of:

#+BEGIN_SRC yaml
  <c_name>:
    name: "<mfactor-name>"
    call: <callspec>
    # following optional line is for void functions, for functions returning a value, don't use
    result: discard
#+END_SRC

  where =<callspec>= describes the function's arguments, e.g. "iis" for a function like =fn(int, int, int16)=.
  Currently supported values are:
  - =v= -> fn(void)
  - =lit= -> for variables (returns their address)
  - =s=, =i=, =b=, =bi=, =ib=, =is=, =ii=, =iis=, =iii= where =i= is =int=, =b= is =int8= and =s= is =int16=

** Basic MFactor concepts
For the complete Factor language, see [[http://docs.factorcode.org/content/article-handbook-language-reference.html][the official documentation]].  The language is
[[https://en.wikipedia.org/wiki/Concatenative_programming_language][concatenative]], and uses generally postfix syntax, e.g. the arguments are written before
the "function call".  [[http://concatenative.org/wiki/view/Concatenative%2520language/Name%2520code%2520not%2520values][This]] provides a good introduction to the concepts of concatenative
languages.

Terminology:
- Word :: the basic user-defined abstraction, like functions in most languages.
- Vocabulary :: comparable to C's compilation unit with interface definition in a header
     file.  Contains a number of word definitions.
- Data Stack :: or Parameter Stack, holds values that are manipulated by words.
- Return Stack :: keeps track of program execution when calling into words and returning.
     In contrast to Forth, not directly accessible by user code.
- Retain Stack :: second stack for data, which is used to set aside stack elements that
     are needed for later.  Used internally by all [[http://docs.factorcode.org/content/article-dip-keep-combinators.html][preserving combinators]].
- Quotation :: block of code enclosed in square brackets (=[]=), that is pushed onto the
     stack as-is, without evaluation.
- Combinator :: word that takes quotations as input.  Probably the most-used is:
     #+BEGIN_SRC factor
       condition-value [
           true-quotation
       ] [
           false-quotation
       ] if
     #+END_SRC
- Primitives :: are the low-level instructions that are executed by the VM.  All words
     are defined in terms of Primitives and other words.
- Image :: is a (compiled) array of primitives, that constitutes the binary representation
     of the mfactor source program
- Dictionary :: generated table that holds information on word definitions, most
     prominently the address of the words's bytecode in the image

** Differences to Factor
Mfactor implements a subset of factor's functionality useful for embedded systems programming.
Major differences:
- no namestack, so no dynamic variables (may change, but high
  performance impact for embedded systems)
- vocabulary search is simplified, vocabulary =foo= would be found in
  =<MFACTOR_SRC_DIR>/foo.mfactor=, vocabulary =foo.bar= would be found in
  =<MFACTOR_SRC_DIR>/foo.bar.mfactor=.
- same-named words in different vocabularies not supported (yet)
- interactive support only for byte-array and integer-array sequences: =B{ }=, =I{ }=, at
  compile time, arbitrary sequences can be used.
- host compiler only supports a subset of syntax words: =:=, =SYNTAX:=, ={ }=, =B{ }=, =I{
  }=, `SYMBOLS:`, =USING:=, =IN=
- =case= is implemented as a syntax word, so no interactive support
- words beginning with underscore(=_=) are not stored in the dictionary.  This is intended
  for helper functions, to prevent them from consuming dictionary space.
- no continuations, no quotation compositions(yet)
- simplified exception handling with `catch` and `throw`
- no Garbage Collector.  Since interactive usage is meant to be for developing, allocated
  objects by the reader are not released automatically.  Any data used in normal code is
  statically compiled into the image, so no runtime allocation is performed unless
  specified explicitely using sequence constructors =<byte-array>= and =<integer-array>=

* Host Compiler

** Concept
The host compiler scans =MFACTOR_SRC_DIR= for the vocabulary specified with
=MFACTOR_ROOT_VOCAB=, and loads it.  When loading a vocabulary, it searches it's own
mfactor sources and the files in =MFACTOR_SRC_DIR= for a file named
=<vocab-name>.mfactor=.  It recursively loads any formerly unloaded vocabularies in the
process.  Loading a vocabulary involves following ruby classes:
#+BEGIN_SRC ditaa :file img/rbcomp.png

Parser -> Image -> ByteCodeImage

#+END_SRC

The Parser reads the source code, checking for syntax errors and generating an internal
representation of the code.  Once all the words have been loaded, the internal =Image=
object is turned into a =ByteCodeImage= object, which is the main output product.

** TODO Parser details
** Bytecode Generator Output
Per default, the output of the rake task is place in subdirectory =generated= of the
including project.  This folder contains several files:
- =inst_enum.h= - enum which contains all instruction mnemonics.  These are used in the
  image generated in =bytecode.c"
- =mfactor_words.h= - contains all exported words, which can then be referenced from C
  context.
- =bytecode.c= - contains the actual byte code image, dictionary and hash table
- =bytecode.h= - some constants which are generated during byte code compilation and
  used in the VM implementation
- =image.dump= - serialized MFactor::ByteCodeImage Object, can be loaded with
  =MFactor::ByteCodeImage::deserialize=.  This basically exposes all possible internals
  about the compiled image.  Used to extract information after compilation, when the
  =mfactor= task has finished.

** Invocation
If =MFACTOR_DEPENDING_OBJECT= was set correctly in the host application's Rakefile, then a
rebuild of the application automatically triggers a recompile of the bytecode image.
** TODO Compilation example
** Details
*** Fried Quotations(WIP)
Fried Quotations (and their basic versions =curry= and =compose=) are the equivalent of
closures.  Creating a closure always means allocating space somewhere.  If the closure
creation is inlined, that space can be allocated by the compiler.  Therefore, fried
quotations are currently only supported on the host compiler, and all quotations
containing them are automatically inlined.  Also, if looping code is used to return
multiple results of fried quotation definitions, note that they will be equal to the last
invocation, since no allocation is performed at compile time.  In theory, a runtime check
could be implemented which signals a runtime error when a quotation is being fried more
than once.

To describe the transformation, consider the following example:
#+BEGIN_SRC factor
  ! for each i where i runs from 0 below n, x is added to it before applying quot to it
  : each-int-added ( n x quot ( i -- ) -- )
      '[ _ + @ ] each-integer; inline
#+END_SRC

Let's define a word that makes use of this word:
#+BEGIN_SRC factor
  ! print values that are passed to the quotation in each-int-added,
  ! the value added to each element is x, it is called 10 times
  : test ( x -- ) 10 swap [ . ] each-int-added ;
#+END_SRC

Conceptually, the following series of transformations is appplied internally when defining =test=:
=test ( n -- ) 10 swap [ . ] '[ _ + @ ] each-integer=
=test ( n -- ) 10 swap [ . ] '[ _ + _ call ] each-integer=
=test ( n -- ) 10 swap [ . ] 0x0002 setmem 0x0001 setmem [ (0x0001) + (0x0002) call ] each-integer=

The locations sites where the "curried-in" data is used are made explicit, and before the
quotation is passed to =each-integer=, code is generated that sets the actual memory
locations to their values at runtime.  This is done even when the values are constant and
known at compile time.

Since it is effectively rewriting the quotation at
runtime, this incurs a small performance hit.  That also illustrates why these words have
to be inlined.  For every use, the quotation must essentially be copied if the rewritten
items are to not interfere with different invocations.

the =@= specifier actually does no splicing, but simply calls the original quotation.
This must be kept in mind if the spliced quotation is mutable in any way.

If code is stored in non-writable memory, another indirection is needed.  The placeholders
are not substituted directly, but filled at runtime by a read to a known writable location:

=test ( n -- ) 10 swap 0x0001 setmem [ . ] 0x0002 setmem '[ 0x0001 getmem + 0x0002 getmem call ] each-integer=

This way, no actual code rewrite is performed, but the item use costs another indirection.
Effectively, this allocates "variables" in a data segment, which the compiler assumes to be writable
at runtime.

Note that both versions introduce the overhead of copying the code of the original
definition containing the fry at every call site!

An obvious optimization here is to separate the last part of the definition, after the
fried quotation, into an own word.  This is very probably almost always the case anyways,
as the example definition above illustrates that typically the quotation is passed to
another combinator.  If that one contains fried quotations, it will obviously further
increase the copied code overhead.

* VM Implementation
:PROPERTIES:
:noweb-ref: vm_c
:END:
The VM is a [[http://en.wikipedia.org/wiki/Stack_machine][stack machine]] with three stacks, a *data stack* (or parameter stack, pstack),
*return stack* and a *retain stack*.

The data stack is used for argument passing, while the return stack is used to save the
program counter during sub-routines (and store some debug information).  The retain stack is only
used for putting stack items out of the way temporarily.

A program counter points to successively executed primitive instructions.

The following 3 Sections describe all definitions that end up in the header file
[[file:src/interpreter.h]], the rest describes the implementation in [[file:src/interpreter.c]]

** Instruction Set
The Instruction Set for the VM is defined in [[file:instructionset.yml]].  For a description
of the instructions see ??? the relevant section later on.

** Definitions and Datatypes
:PROPERTIES:
:noweb-ref: vm_h
:END:
In [[file:src/interpreter.h]] are relevant data type definitions and preprocessor macro
defaults.  These are supposed to be overriden to configure the compiled runtime (see
???).

*** Typedefs

**** Scalar Types
The type of actual primitive instructions which are loaded and evaluated, and from which
byte code images are constructed. (see ???)
Size: 1 byte
#+begin_src C
typedef unsigned char inst;
#+end_src

Targets of normal jumps and calls.  16 bit size, so if an image is bigger than 64K, these
are not sufficient (see ???call instructions)
Size: 2 bytes
#+begin_src C
  typedef unsigned short short_jump_target;  /* relative jumps in 64k on 32 bit */
#+end_src

Targets of long jumps. Use full 32 Bit address space.  Used for calls to addresses on
stack.
Size: 32 Bit
#+begin_src C
  typedef uintptr_t jump_target;  /* long absolute jump */
#+end_src

Type of data actually manipulated on the stack.
Size: 32 Bit
#+begin_src C
typedef uintptr_t cell;                 /* memory cell must at least hold pointer */
#+end_src

**** Dictionary entries<<dict-entry-struct>>

Type of entries in the dictionary.  These map names to addresses, and hold the flags that
mark a word inline, recursive, or a parsing word.
#+begin_src C
  typedef struct dict_entry
  {
     inst * address;           /* pointer into memory */
     unsigned char flags; /* may include other flags later (inline, recursive, etc) */
     unsigned char name_header;      /* should always be zero */
     unsigned char name_length;
     char name[];
  } __attribute__((packed)) dict_entry;
#+end_src

*** <<vm-preprocessor-macros>>Preprocessor Macros

The following all indicate the size of the different components, in =cell= units.
These are defaults can be changed according to application requirements.


#+begin_src C
  /* data memory (affects non-transient data) in cells*/
  #ifndef VM_MEM
          #define VM_MEM 256
  #endif

  /* dictionary size (affects number of named items)*/
  #ifndef VM_DICT
          #define VM_DICT 512
  #endif

  /* parameter stack size (affects transient data)*/
  #ifndef VM_PSTACK
          #define VM_PSTACK 64
  #endif

  /* return stack size (affects nesting of functions)*/
  #ifndef VM_RETURNSTACK
          #define VM_RETURNSTACK 64
  #endif

  /* retain stack size (affects maximum amount of postponing data use) */
  #ifndef VM_RETAINSTACK
          #define VM_RETAINSTACK 32
  #endif
#+end_src

Another macro can be preset or computed: =INSTBASE=.  This is used to distinguish
primitive instructions from quotations, when executing words on the stack.  Primitives
cannot be interpreted as memory addresses, since these would point into invalid memory.

On Cortex-M, all memory addresses higher than 0x80... are not accessable, and can be
used for primitive instructions.
#+begin_src C
  #ifndef INSTBASE
   #if (__linux && __LP64__)
    #define INSTBASE 0x80U
   #elif (CORTEX_M)
    #define INSTBASE 0xA0U
   #else
    #error "don't know instruction code base for architecure!"
   #endif
  #endif
#+end_src

This influences the opcodes generated in =inst_enum.h= during building.

A =cell=-sized version for comparison to data values:

#+begin_src C
#define INSTBASE_CELL ((cell)INSTBASE<<(8*(sizeof(inst *)-sizeof(inst))))
#+end_src

*** Defines for the generated data in =bytecode.c=

#+begin_src C
extern inst image[];
extern dict_entry dict[VM_DICT];
extern uint16_t dict_hash_index[];
extern cell FF_Table[];
#+end_src

=image= holds the actual firmware image, =dict= is the dictioary, =dict_hash_index=
creates a hash table for fast lookup of words (see ???). =dict= is declared with size
because in the lookup function the =sizeof()= operator is used for bounds-checking.

*** Main VM Function Prototype
This is the prototype for the function that is supposed to be executed from the
application program.  The only argument is the offset of the first in the bytecode image
to be executed.  The return value indicates the status after a bytecode-program has been
executed.  If it is non-zero, an internal error happened.

#+begin_src C
int interpreter(short_jump_target);
#+end_src

** Special Variables Definition
The internal state of the interpreter is exposed to the application by predefining an
array of special variables.  These are needed for all instructions that depend on state
that must be influenced by the application.

First define an array that holds these Variables:

#+BEGIN_SRC C
  #define _NumSpecials 10
  static const unsigned char NumSpecials = _NumSpecials;
  static cell special_vars[_NumSpecials];
#+END_SRC

The list of currently implemented specials:
#+BEGIN_SRC C
  /* currently implemented special variables
  0: MP - memory write pointer
  1: HANDLER - handler frame location in r(etain) stack (dynamic chain for catch frames)
  2: DEBUG_LEVEL - 0 to turn off, increasing will produce more verbose debug output
  3: RESTART - word where to restart when hard error occured
  4: STEP_HANDLER - address of handler which can be used for single stepping
  5: BASE - address of current 64k segment base
  6: OUTPUT_STREAM: 1: stdout, 2: stderr, 3: null
  */
#+END_SRC

Not all of them are actually in use, the ones that are, are defined as macros so that the
=special_vars= array needs not be acccessed directly in the following source code:

*** =MP=: The Memory Write Pointer
This holds a pointer to the memory location that is accessed by the compilation primitives
(TOOD: link)
#+BEGIN_SRC C
  #define MP special_vars[0]
#+END_SRC

*** =HANDLER=: Current Exception handling frame
This is used by the application to store information about the current exception handler.
Note that the application does not currently manipulate or access this state, so it is
basically a specialized global variable. TODO: reference the exception handling lib
#+BEGIN_SRC C
  #define HANDLER special_vars[1]
#+END_SRC

*** =DEBUG_LEVEL=: VM Debug Verbosity
Used to activate debug output for VM internals.  Only used for VM development and debugging.
#+BEGIN_SRC C
  #define DEBUG_LEVEL special_vars[2]
#+END_SRC

*** =RESTART=: Restart address (deprecated)
This used to hold an address that was jumped to in case of internal errors.  This has been
replaced by returning from =interpreter()= with the internal error code, and the host
application deciding what to do then

*** =STEP_HANDLER=: Single Stepping Handler (not in use)
This shall hold an address which is called on every step of the currently executed bytecode
image.  Meant for implementing single step debugging, where the actual handler would be
written as mfactor source.

*** =BASE=: Current Segment base address
This hold the address that is added to *all* internal calls (TODO: link to relevant call
primitives).  Usually it holds the address of the =image=-variable, that is generated in
=generated/bytecode.c=.  This allows the image to be relocatable, so that the actuall call
target (16 bit value) is computed by adding it to the value of =BASE=.

#+BEGIN_SRC C
  #define BASE special_vars[5]
#+END_SRC

*** =OUTPUT_STREAM=: Output Stream descriptor
The value of this variable is used everytime something should be output.  It determines
which =File= pointer is passed to the standard c output functions in =current_fd()= (TODO
link)
#+BEGIN_SRC C
  #define OUTPUT_STREAM special_vars[6]
#+END_SRC

The possible values are defined as:
#+BEGIN_SRC C
  /* known stream descriptors for OUTPUT_STREAM */
  #define STDOUT 1
  #define STDERR 2
  #define NULLOUT 3
#+END_SRC

** <<init-specials-definition>>Special Variables Initialization
#+BEGIN_SRC C
  static void init_specials() {
     HANDLER = 0;
     MP = (cell)memory; /* start of user memory */
     BASE = (cell)&image; /* start of bytecode segment */
     OUTPUT_STREAM = STDOUT; /* output to standard output per default */
  }
#+END_SRC
** Helper Funtions
*** Internal Debugging
**** Output Handling
One file-local variable that holds the current Output stream for internal messages:
#+BEGIN_SRC C
  static FILE * Ostream; /* used by reporting functions, so they can temporarily
                            print to different file descriptor */
#+END_SRC
**** Debug Level
One helper for checking if the current debug level is high enough for subsequent actions:

#+BEGIN_SRC C
  /* check if current value of debug is greater or equal to val */
  static bool debug_lvl(unsigned int val) {
     return (DEBUG_LEVEL >= val);
  }
#+END_SRC

*** Work Memory
For allocation of interactively-generated input sequences, such as strings, byte arrays and
quotations, internal memory is reserved.  This is the default target area for the
compilation primitives (TODO: link).

#+BEGIN_SRC C
  /* main memory to work with */
  static cell memory[VM_MEM];
#+END_SRC

*** Return Stack Entry Format
The return stack, which holds the links of the dynamic chain, has entries in the following
format:
#+BEGIN_SRC C
  typedef struct return_entry {
     inst * return_address;
     inst * current_call;
  } return_entry;
#+END_SRC

Technically, for execution, only the =return_address= portion is interesting.  But for
debugging purposes and backtraces it is useful to record the starting address of the
current quotation.  This is done with the =current_call= field.

*** Word Lookup: Dictionary support
There is built-in support for work lookup in the dictionary (see TODO: link to dictionary
explanation), mainly for speed reasons.  During compilation, a simple hash table was
created by the ruby translator (TODO: link).  This code is the runtime access portion.  It
uses a very simple hash function to look up a starting index that can be used for looking
up a word with a linear search from there.

#+BEGIN_SRC C
  uint32_t lookup_ht_entry(uint8_t length, char* name) {
     uint32_t hash = 5381;
     for (int i = 0; i < length; i++) {
        hash = hash * 33 + name[i];
     }
     return (cell)dict+dict_hash_index[hash%256];
  }
#+END_SRC

For debugging, there is a (slow) reverse lookup, that gets the word name from its
execution address:

#+BEGIN_SRC C
  /* get the name of the word, only for debugging */
  /* probably fails for non-null-terminated strings */
  static char* find_by_address( inst * word)
  {
     static char notfound[] = "(internal or private)";
     for (char * ptr=(char*)dict;
          (ptr < ((char*)dict+sizeof(dict)))&&(((dict_entry*)ptr)->name_length > 0);
          ptr += (((dict_entry*)ptr)->name_length + 3*sizeof(unsigned char) + sizeof(void*))) {
        dict_entry *dptr = (dict_entry*)ptr;
        if (dptr->address == word)
           return dptr->name;
     }
     return notfound;
  }
#+END_SRC

*** Parsing Numbers

Whenever a piece of input is unknown, it is tried to parse as a number before giving up.
This uses libc's =sscanf()=, and is exposed via the =parsenum= primitive, which uses this
function.

#+BEGIN_SRC C
  static bool parse_number(char *str, cell * number){
     int num;
     unsigned int read = sscanf(str,"%i",&num);
     if (read == 1) {
        *number = (cell)num;
        return true;
     } else {
        return false;
     }
  }
#+END_SRC

*** Debug output
For the =st= primitive and in case of errors, the stack contents are sometimes printed to
=stderr=.  This is done with the following file-local functions:

#+BEGIN_SRC C
  /* display data stack entries */
  static void printstack(cell * sp, cell * stack)
  {
     fprintf(Ostream, "stack:");
     for(cell* ptr = stack;ptr < sp;ptr++)
     {
        fprintf(Ostream, " %#lx",*ptr);
     }
     fprintf(Ostream, "\n");
  }

  /* display return stack entries */
  static void print_return_stack(return_entry * sp, return_entry * stack, inst * base)
  {
     fprintf(Ostream, "stack:");
     for(return_entry* ptr = sp-1;ptr >= stack;ptr--)
     {
        fprintf(Ostream, " {%#lx->%#lx}",((uintptr_t)ptr->current_call-(uintptr_t)base),
                ((uintptr_t)ptr->return_address)-(uintptr_t) base);
     }
     fprintf(Ostream, "\n");
  }

  /* print a backtrace of the return stack */
  static void backtrace(return_entry * sp, return_entry * stack, inst * base, inst * pc)
  {
     fprintf(Ostream, "backtrace @ %#lx:\n",(uintptr_t)(pc-base));
     for(return_entry* ptr = sp-1;ptr >= stack;ptr--)
     {
        char *current_name = find_by_address(ptr->current_call);
        fprintf(Ostream, "%#lx %s\n",(uintptr_t)(ptr->current_call - base),current_name);
     }
  }
#+END_SRC
** Used Subroutines (defined as Macros)
There are several subroutines that are repeatedly used in =interpreter()=, which operate
on the static data that is only defined there.  Because of that, they are implemented as
preprocessor macros.
*** Backtrace printing
#+BEGIN_SRC C
  #define BACKTRACE() do {                                 \
        FILE * old_out = Ostream;                          \
        Ostream = stderr;                                  \
        printstack(psp,pstack);                            \
        printstack(retainsp,retainstack);                  \
        backtrace(returnsp,returnstack,(inst *)BASE,pc);   \
        Ostream = old_out;                                 \
     }       while (0)                                     \
#+END_SRC
*** Errors during primitive execution
Whenever something unrecoverable handles, this is called.  Currently just returns the
error code from =interpreter()=.

#+BEGIN_SRC C
  #define handle_error(code) do {return code;} while(0)
#+END_SRC
*** Stack Operation Assertion
These macros are used when popping and pushing elements on stacks, and check if the stack
is empty or full.
#+BEGIN_SRC C
  #define assert_pop(sp,min,name,fail_reason) if (sp <= min) { print_error(name "stack underflow");BACKTRACE();handle_error(fail_reason);}
  #define assert_push(sp,min,size,fail_reason) if (sp > min+size){ print_error("stack overflow");BACKTRACE();handle_error(fail_reason);}
#+END_SRC
*** Stack operations
These macros are the basic internal stack manupulation functions.  All stacks are assumed
empty ascending.  The following routines are general:

Peeking into the stack (as opposed to removing a value), currently only used for the
=_dup= primitive

#+BEGIN_SRC C
  #define peek_n(sp,nth) (*(sp-nth))
#+END_SRC

Basic push and pop operations.  The underscores are for avoiding name clashes.
#+BEGIN_SRC C
  /* push value onto stack indicated by stack pointer sp */
  #define push_(sp,val) *sp=val;sp++;
  /* pop value from stack indicated by stack pointer sp */
  #define pop_(sp) --sp;*sp;
#+END_SRC

The rest is meant for the three specific stacks (TODO: link to stack explanation).  The
push functions push (safely) a value onto the respective stack.  The pop functions pop (safely) a
value from the respective stack.
**** Data Stack (Parameter Stack)
#+BEGIN_SRC C
  #define ppush(val) ({assert_push(psp,pstack,VM_PSTACK,INTERNAL_ERROR_PSTACK_OFLOW);push_(psp,val)})
  #define ppop() ({assert_pop(psp,pstack,"p",INTERNAL_ERROR_PSTACK_UFLOW);pop_(psp)})
#+END_SRC
**** Return Stack
#+BEGIN_SRC C
  #define returnpush(val) ({assert_push(returnsp,returnstack,VM_RETURNSTACK,INTERNAL_ERROR_RSTACK_OFLOW);push_(returnsp,val)})
  #define returnpop() ({assert_pop(returnsp,returnstack,"return",INTERNAL_ERROR_RSTACK_UFLOW);pop_(returnsp)})
#+END_SRC
**** Retain Stack
#+BEGIN_SRC C
  #define retainpush(val) ({assert_push(retainsp,retainstack,VM_RETAINSTACK,INTERNAL_ERROR_RTSTACK_OFLOW);push_(retainsp,val)})
  #define retainpop() ({assert_pop(retainsp,retainstack,"retain",INTERNAL_ERROR_RTSTACK_OFLOW);pop_(retainsp)})
#+END_SRC
** Main Interpreter function =interpreter()=
Basic Flowchart
#+BEGIN_SRC plantuml :file img/interpreter_flow.svg :noweb-ref nil
  start
   :initialize **pc** to **start_address**,
   reset stack pointers,
   set internal state to default values;
   :push the start frame to the return stack;
   repeat
    :set **i** to the instruction pointed to by **pc**;
    :increase **pc** by one;
    :execute the primitive denoted by **i**;
    note left
     Execution of the primitives modifies
     internal state.  If primitives read
     data from the instruction stream,
     they increase **pc** accordingly so
     it points to the next instruction.
    end note
    if (error encountered during primitive execution) then (yes)
     :return internal error code;
     stop
    else (no)
    endif
   repeat while (**i** != quit)
   :return 0;
  stop
#+END_SRC

#+RESULTS:
[[file:img/interpreter_flow.svg]]

The =interpreter()= functions is structured as follows:

#+BEGIN_SRC C :noweb-ref interpreter :noweb tangle
  int interpreter(short_jump_target start_address) {

     <<state_definition>>

     <<state_initialization>>

     while(1) {
        inst i;
        i = (*pc++);
     dispatch:
        <<debug_statements>>
        switch(i) {
           <<big_fat_switch>>
           default:
              printf("unimplemented instruction %#x\n",i);
              handle_error(INTERNAL_ERROR_INVALID_OPCODE);
        }
     goto end_inst;  /* normal instructions skip the call execution paths */
     nested_call:  /* common execution path for non-tail calls */
        <<nested_call_common>>
     tail_call:    /* common execution path for tail calls */
        <<tail_call_common>>
     end_inst:     /* end of instruction processing */
        (void) 0;
     }
  }
#+END_SRC

The labels after the switch statement are common exit points of several primitives.

*** Internal State Definition
:PROPERTIES:
:noweb-ref: state_definition
:END:

**** Stacks
- data stack (or parameter stack) and pointer
- return stack and pointer
- retain stack and pointer
#+BEGIN_SRC C
  /* parameter stack */
  static cell pstack[VM_PSTACK]={0};
  static cell* psp;
  psp = &pstack[0];
  /* return stack */
  static return_entry returnstack[VM_RETURNSTACK]={{0}};
  static return_entry* returnsp;
  returnsp = &returnstack[0];
  /* retain stack */
  static cell retainstack[VM_RETAINSTACK]={0};
  static cell* retainsp;
  retainsp = &retainstack[0];
#+END_SRC

The data and retain stacks are using scalar elements of type =cell=, while the return
stack holds structs.

The size macros are defined in the header file (see [[vm-preprocessor-macros]]), and control the
memory usage of the VM.
**** Program counter
This is the most basic state for any program interpreting machine.  It holds the address
of the next primitive instruction in the instruction stream (bytecode image).
#+BEGIN_SRC C
  inst *pc;
  pc = &image[(start_address ? : START_WORD_OFFSET)];  /* point to the start of the program */
#+END_SRC

The initial value is either taken from the =interpreter()= call as parameter, or by using
the =START_WORD_OFFSET= macro from =bytecode.h=, that translates the =START_WORD= global
variable (see [[Configuring the Rake Task]]) into an address.

**** Tail Call Optimization
The MFactor implementation relies on (explicit) [[https://en.wikipedia.org/wiki/Tail_call][tail call elimination]].  Because of the
nature of the language, the compiler can detect all cases of tail calls easily and
replaces the =call= instructions with their =tcall= equivalents:
- =bcall= -> =btcall=
- =scall= -> =stcall=
- =acall= -> =atcall=

The =tcall= instructions all amount to a jump to the called word, thus replacing the
current stack frame instead of adding one to the dynamic chain.  Since Iteration is
implemented with (tail)-recursion, disabling tail calls severly limit loop execution, and
should only be turned on locally for debugging purposes.
This variable controls wether tail calls should be handled as such, or redirected to
nested calls:
#+BEGIN_SRC C
  static bool tailcall;
  tailcall = true;  /* enable tail call jumping by default */
#+END_SRC
**** Helper "Register"
To help manage jumping through the code, a variable =x= is defined here and used in
various primitive instructions.  Normally, the needed variables are defined locally in the
intruction cases.
#+BEGIN_SRC C
  cell x; /* temporary value for operations */
#+END_SRC
**** Debug Mode
To debug internals, this =debug_mode= state can be set (also via an isntruction, TODO:
link).  If so, it outputs internal state before processing an instruction, and waits for a
keypress before processing it.  The =debug_nest= counter is used to keep track of return
stack levels to make sure debug mode is exited corretly and to provide nesting
information.
#+BEGIN_SRC C
  /* single step debugging*/
  unsigned int debug_nest = 0; /* used in debug mode to track when
                                ,* to stop single stepping*/
  bool debug_mode = false;
  #if DEBUG
  debug_mode=true;
  #endif
#+END_SRC
*** State initialization
:PROPERTIES:
:noweb-ref: state_initializiation
:END:
The initial of the vm: Program counter points to the starting word, data and retain stack
empty, return stack contains a default frame.
**** Output File Descriptor
The value passed to all libc stdio commands used during primitive instruction execution.
#+BEGIN_SRC C
  Ostream = stdout;  /* print everything to stdout per default */
#+END_SRC

**** Special Variable Initalization
See [[init-specials-definition]].
#+BEGIN_SRC C
  init_specials();
#+END_SRC

*** Primitive Instructions
:PROPERTIES:
:noweb-ref: big_fat_switch
:END:
All the primitives, that defined words consist of, are described here.

**** Basic stack manipulation
- =drop= :: remove value on top of parameter stack
- =dup= :: (internally named _dup to avoid name conflits) duplicate the item on top of
     stack

#+BEGIN_SRC C
     case drop: ppop();
     case _dup: ppush(peek_n(psp,1));
#+END_SRC

**** Arithmetic instructions
All arithmetic instructions either manipulate the value on top of the stack, or replace
the two top values with the results.  For defining unary and binary operations with C
operators, two helper macros are used:

#+BEGIN_SRC C
  #define UNOP(op) {                              \
        x=(op ((intptr_t) ppop()));               \
        ppush(x);                                 \
     } break
  #define BINOP(op) {                                                     \
        x = ppop();                                                       \
        cell y = ppop();                                                  \
        ppush(((intptr_t)y) op ((intptr_t)x));                            \
     } break
#+END_SRC

The instructions themselves:
#+BEGIN_SRC C
  case add: BINOP(+); break;
  case mul: BINOP(*); break;
  case sub: BINOP(-); break;
  case neg: UNOP(-); break;
  case asl: BINOP(<<); break;  /* arithmetic shift left */
  case asr: BINOP(>>); break;  /* arithmetic shift right */
  case div: BINOP(/); break;
  case mod: BINOP(%); break;
  case bitand: BINOP(&); break;
  case bitor: BINOP(|); break;
  case bitxor: BINOP(^); break;
  case bitnot: UNOP(~); break;
  case gt: BINOP(>); break;
  case lt: BINOP(<); break;
#+END_SRC

**** Constants
These push constants onto the stack.  These save space compared to pushing a literal onto
the stack, which takes two bytes instead of one.
#+BEGIN_SRC C
     case zero: ppush(0); break;
     case one: ppush(1); break;
     case two: ppush(2); break;
#+END_SRC
**** Informational Instructions
These provide information about some internals to the application:
- work memory bounds
- dictionary bounds
- size in bytes of stack elements (platform-dependent)
- starting instruction code
dictionary.
#+BEGIN_SRC C
     case memstart: ppush((cell)memory); break;
     case memend: ppush((cell)(memory+VM_MEM)); break;
     case dictstart: ppush((cell)dict); break;
     case dictend: ppush((cell)(dict+VM_DICT)); break;
     case cellsize: ppush((cell)sizeof(cell)); break;
     case instbase: ppush((cell)INSTBASE); break;
#+END_SRC

* Appendix: Complete Sources
** interpreter.h
#+name: interpreter_h
#+begin_src C :tangle ../src/interpreter.h
#ifndef INTERPRETER_H
#define INTERPRETER_H

#include <stdbool.h>
#include <stdint.h>
#include "generated/bytecode.h"

<<vm_h>>

#endif

#+end_src
** interpreter.c
#+name: interpreter_c
#+BEGIN_SRC C :tangle ../src/interpreter.wip.c
  #include "interpreter.h"
  #include "reader.h"
  #include <string.h>
  #include <stddef.h>
  #include <stdio.h>
  #include <stdbool.h>

  /* these are available after mfactor task has run */
  #include "generated/bytecode.h"
  #include "generated/inst_enum.h"

  /* target specific stuff */
  #include "runtime.h"
  #include "reset_system.h"

  #include "seq_headers.h"

  <<vm_c>>

  <<interpreter>>

#+END_SRC
