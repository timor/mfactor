#+TITLE:     MFactor Documentation
#+EMAIL:     timor.dd@googlemail.com
#+DATE:      2015-03-17 Di
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: timestamp:nil h:4 author:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/bigblow.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/bigblow/css/hideshow.css"/>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-1.11.0.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery-ui-1.10.2.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.localscroll-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.scrollTo-1.4.3.1-min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/jquery.zclip.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/bigblow.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/bigblow/js/hideshow.js"></script>


#+STARTUP: indent
* Overview
MFactor is an (incomplete) implementation of the [[http://factorcode.org/][factor language]] for embedded systems.
It consists of two parts:

A *host compiler*, written in Ruby, which is used with the [[https://github.com/ruby/rake][Rake]] build system to produce a
binary image.

A *c implementation of a bytecode vm* which is able to execute such an image.


** General Concept
The general idea is as follows:
#+BEGIN_SRC ditaa :file img/concept.png
  +---------+
  |.mfactor +----+
  |source   |    |
  |files    |    |
  +---------+    |
                 v
        +-----------+       +---------------------+
        | rake task |       |vm implementation .c |
        |           |       |{d}                  |
        |           |       +---------------------+
        +-----------+                |
             |                       v
             v                +----------------+    +--------------+
      +--------------+        | regular        |    |c application |
      |bytecode image|------->| compilation    |<---|{d}           |
      |  {d}         |        |                |    +--------------+
      +--------------+        +----------------+
                                    |
                                    |
                    +--------+      |
                    |binary  |      |
                    |{d}     |<-----+
                    |        |
                    +--------+
#+END_SRC

In order to incorporate this into a project, several rake tasks are supplied in [[file:../tasks/mfactor.rake][tasks/mfactor.rake]]

- *mfactor*: the main task, which, when called, generates above code
- *mftest[word name]*: helper task, outputs a graphical representation of a specific word in the =generated= subdir.

** Configuring the Rake Task
The rake file is supposed to be included with rake's =import= facility.

Currently, it is configured via setting global variables:
- =MFACTOR_SRC_DIR=: determines the directory where the application's mfactor sources can be found
- =GENERATOR=: which bytecode backend to use, currently, only =Cortex= is supported
- =START_WORD=: word, which will be executed when starting the vm
- =MFACTOR_ROOT_VOCAB=: the root vocabulary, which is first loaded and loads all dependencies
- =MFACTOR_DEPENDING_OBJECT=: To cause Rake to recompile the whole application, this
  should be set to an object file in the application which contains the bytecode image.
- =MFACTOR_C_WORDS=: Hashtable for exposing word locations in bytecode to C. Format:
  #+BEGIN_SRC ruby
      { "mfactor-word-name" => "NAME_OF_CPP_DEFINE" }
  #+END_SRC
- =FF_MFACTOR=: path to file containing interface definitions to c code (see [[*Making%20Existing%20C%20Functions%20Available][Making Existing C Functions Available]])

** Making Existing C Functions Available
Special global variable =FF_MFACTOR= can be set to a yaml file for
"importing" existing c functions into the interpreter's namespace (Foreign function interface).
entries are in the form of

#+BEGIN_SRC yaml
  <c_name>:
    name: "<mfactor-name>"
    call: <callspec>
#+END_SRC

  where =<callspec>= describes the function's arguments, e.g. "iis" for a function like =fn( int, int, int16)=.
  Currently supported values are:
  - =v= -> fn(void)
  - =lit= -> for variables
  - =i=, =b=, =bi=, =iis=, =iii= where =i= is =int=, =b= is =int8= and =s= is =int16=

** Invoking the Rake Task
If =MFACTOR_DEPENDING_OBJECT= was set correctly, then a rebuild of the application
automatically triggers a recompile of the bytecode image.

* Host Compiler

** Concept
The host compiler scans =MFACTOR_SRC_DIR= for the vocabulary specified with
=MFACTOR_ROOT_VOCAB=, and loads it.  It recursively loads any formerly unloaded
vocabularies in the process.  Loading a vocabulary involves following ruby classes:
#+BEGIN_SRC ditaa :file img/rbcomp.png

Parser -> Image -> ByteCodeImage

#+END_SRC
** Bytecode Generator Output
Per default, the output of the rake task is place in subdirectory =generated= of the
including project.  This folder contains several files:
- =inst_enum.h= - enum which contains all instruction mnemonics.  These are used in
  =image.code.h=
- =mfactor_words.h= - contains all exported words, which can then be referenced from C
  context. (see ???)
- =image.code.h= - contains the actual byte code image
- =image.dict.h= - contains the dictionary, excluding private words (see ???)
- =image_size.h= - some constants which are generated during byte code compilation and
  used in the VM implementation

* VM Implementation
The VM is a [[http://en.wikipedia.org/wiki/Stack_machine][stack machine]] with three stacks, a *data stack*, *return stack* and a *retain
stack*.

** Instruction Set
The Instruction Set for the VM is defined in [[file:instructionset.yml]].  For a description
of the instructions see ??? the relevant section later on.

** Implementation
This section describes the implementation of the VM in [[file:src/interpreter.c]]

*** Header File
:PROPERTIES:
:noweb-ref: vm_h
:END:
In [[file:src/interpreter.h]] are relevant data type definitions and preprocessor macro
defaults.  These are supposed to be overriden to configure the compiled runtime (see
???).

**** Typedefs

The type of actual primitive instructions which are loaded and evaluated, and from which
byte code images are constructed. (see ???)
Size: 1 byte
#+begin_src C
typedef unsigned char inst;
#+end_src

Targets of normal jumps and calls.  16 bit size, so if an image is bigger than 64K, these
are not sufficient (see ???call instructions)
Size: 2 bytes
#+begin_src C
  typedef unsigned short short_jump_target;  /* relative jumps in 64k on 32 bit */
#+end_src

Targets of long jumps. Use full 32 Bit address space.  Used for calls to addresses on
stack.
Size: 32 Bit
#+begin_src C
  typedef uintptr_t jump_target;  /* long absolute jump */
#+end_src

Type of data actually manipulated on the stack.
Size: 32 Bit
#+begin_src C
typedef uintptr_t cell;                 /* memory cell must at least hold pointer */
#+end_src

**** The Image
The image generated in =image.code.h= is declared here:

#+begin_src C
inst image[IMAGE_SIZE];
#+end_src

=IMAGE_SIZE= is generated, and exported in =image_size.h=.
See also [[*Bytecode%20Generator%20Output][Bytecode Generator Output]]

**** Preprocessor Macros

The following all indicate the size of the different components, in =cell= units

#+begin_src C
  /* data memory (affects non-transient data) in cells*/
  #ifndef VM_MEM
   #define VM_MEM 256
  #endif
  
  /* dictionary size (affects number of named items)*/
  #ifndef VM_DICT
   #define VM_DICT 512
  #endif
  
  /* parameter stack size (affects transient data)*/
  #ifndef VM_PSTACK
   #define VM_PSTACK 64
  #endif
  
  /* return stack size (affects nesting of functions)*/
  #ifndef VM_RETURNSTACK
   #define VM_RETURNSTACK 64
  #endif
  
  /* retain stack size (affects maximum amount of postponing data use) */
  #ifndef VM_RETAINSTACK
   #define VM_RETAINSTACK 32
  #endif
#+end_src

Another macro can be preset or computed: =INSTBASE=.  This is used to distinguish
primitive instructions from quotations, when executing words on the stack.  Primitives
cannot be interpreted as memory addresses, since these would point into invalid memory.

On Cortex-M, all memory addresses higher than 0x80... are not accessable, and can be
used for primitive instructions.
#+begin_src C
  #ifndef INSTBASE
   #if (__linux && __LP64__)
    #define INSTBASE 0x80U
   #elif (CORTEX_M)
    #define INSTBASE 0xA0U
   #else
    #error "don't know instruction code base for architecure!"
   #endif
  #endif
#+end_src

A =cell=-sized version for comparison to data values:

#+begin_src C
#define INSTBASE_CELL ((cell)INSTBASE<<(8*(sizeof(inst *)-sizeof(inst))))
#+end_src

**** Main VM Function Prototype
This is the prototype for the function that is supposed to be executed from the
application program.  The only argument is the offset of the first in the bytecode image
to be executed.

#+begin_src C
void interpreter(short_jump_target);
#+end_src

** Complete Source Files
*** interpreter.h
#+name: interpreter_h
#+begin_src C :tangle ../src/interpreter.h
#ifndef INTERPRETER_H
#define INTERPRETER_H

#include <stdbool.h>
#include <stdint.h>
#include "generated/image_size.h"

<<vm_h>>

#endif

#+end_src


* local vars                                                       :noexport:

# Local Variables:
# eval: (setq-local org-babel-default-header-args:C '((:noweb . "yes")))
# End:


