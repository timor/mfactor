! -*- mode: factor -*-
! top level loop
: top ( -- ) _test1 _init_storage listener ;

: t ( -- t ) 1 ;
: f ( -- f ) 0 ;

! some unit tests
: _test1 ( -- ) [ [ 'b' emit ] 'a' emit call ] call _test2 nl _test3 _test4 _test5 _test6 _test7 _testend ;
: _test2 ( -- ) 'c' emit [ f ] loop ;
: _test3 ( -- ) 5 [ dup '0' + emit 1 - dup ] loop . ;
: _test4 ( -- ) 254 memstart setbyte 175 memstart 1 + setbyte memstart get .x ;
: _test5 ( -- ) 5 [ dup 0 = not ] [ [ '0' + emit ] [ 1 - ] bi ] while . ;
: _test6 ( -- ) B{ 5 4 3 2 1 } [ '0' + emit ] ba-each 0 . ;
: _test7 ( -- ) 5 [ dup 0 = ] [ [ '0' + emit ] [ 1 - ] bi ] do until . ;
: _testend ( -- ) [ "tests done." print ] call nl ;

! listener
: unknown-token ( tok -- ) parsenum [ nop ] [ _bad-input ] if ;
: listener ( -- ) prompt token find [ _quot>> call ] [ unknown-token ] if listener ;
! : listener2 ( -- ) prompt scan-word drop [ 2 = ] [ 0 = ] bi or [ call ] when listener2 ;
: prompt ( -- ) psplevel pwrite '>' emit ' ' emit ;
: nl ( -- ) 10 emit ;
: _bad-input ( input -- ) drop 'X' dup '_' swap emit emit emit nl ;

: and ( obj1 obj2 -- ? ) over ? ;
: or ( obj1 obj2 -- - ) dupd ? ;
: not ( ? -- \? ) 0 1 ? ;

: >= ( n1 n2 -- ? ) 2dup > [ 2drop t ] [ = ] if ;
: in-range ( val start end -- ? ) [ over [ >= ] dip ] dip < and ;

! unsafe access
: getmem ( addr -- ) _get ;
: getmem8 ( addr -- ) _getbyte ;

: setmem ( val addr -- ) _set ;
: setmem8 ( val addr -- ) _setbyte ;

! safe access
! : _safeset ( value address setter: ( val addr -- ) -- ) [ dup memrange [ 2drop ] 2dip in-range ] dip swap  [ call ] [ 3drop "safe set failed" print error ] if ;
! use same memory range constraint as read for now
: _safeset ( value address setter: ( val addr -- ) -- ) [ dup memrange 2drop in-range ] dip swap  [ call ] [ 3drop "safe set failed" print error ] if ;
: setbyte ( byteval addr -- ) [ _setbyte ] _safeset ;
: set ( val addr -- ) [ _set ] _safeset ;

: _safeget ( address getter: (addr -- val ) -- val ) [ dup memrange 2drop in-range ] dip swap [ call ] [ 2drop "safe get failed" print error ] if ;
: getbyte ( addr -- byteval ) [ _getbyte ] _safeget ;
: get ( addr -- val ) [ _get ] _safeget ;

! memory pointers:
! MP: make-pointer for comma operations,
! lastname: last compiled name, used for setting flags (immediate, inline, recursive)
: _init_storage ( -- ) memstart cell + _MP set ;
: _MP ( -- MP ) memstart ;

: showmem ( -- ) memstart _MP get [ 2dup >= [ f ] [ [ dup getbyte .x 1 + ] dip t ] if ] loop 2drop ;

: _dprint ( c name -- c ) print ": " print dup .x ;
! find next free dictionary entry (check for first name byte = 0)
! dict_entry layout: addr(4)|flag(1)|namelength(1)|name(namelength)
: _free-name ( -- addr ) dictstart [ cell + 1 + dup getbyte [ + 1 + ] keep 0 = not ] loop cell - 2 - ;

! save quotation in dictionary, non-immediate, name is counted string, add terminating 0 for compatibility
: name ( quot name -- ) _free-name [ swap , 0 b, dup strlen 1 + b, [ b, ] ba-each 0 b, ] with-MP ;

! apply q to var's value and update var
: change ( var q: ( old -- new ) -- ) [ [ get ] keep ] dip dip set ;
! incf var
: +@ ( n var -- ) [ + ] change ;

: shift ( x n -- y ) dup 0 > [ asl ] [ neg asr ] if ;

! temporarily different memory pointer
: with-MP ( addr quot -- ) swap _MP get [ _MP set call ] dip _MP set ;

! compilation, forward and reverse
: b, ( byteval -- ) _MP [ get setbyte ] [ 1 swap +@ ] bi ;
: -b, ( byteval -- ) _MP [ 1 neg swap +@ ] [ get setbyte ] bi ;
! ! compile short to mem, little endian
: s, ( short -- ) dup b, 8 neg shift b, ;
: -s, ( short -- ) dup 8 neg shift -b, -b, ;
! compile cell
: , ( val -- ) cell [ dup b, 8 neg shift ] times drop ;
: -, ( val -- ) cell [ cell 1 - neg + 8 * over swap shift -b, ] each-integer drop ;

: square ( x -- xÂ² ) dup * ;

: if ( cond true false -- true/false ) ? call ;
: when ( ..a ? true: ( ..a -- ..a ) -- ..a ) [ nop ] if ;

! some stack shufflers and combinators
: nip ( x y - y ) swap drop ;
: dip ( x quot -- x ) swap >r call r> ;
: 2dip ( x y quot -- x y ) swap [ dip ] dip ;
: 3dip ( x y z quot -- x y z ) swap [ 2dip ] dip ;
: 2dup ( a b  -- a b a b ) over over ;
: dupd ( x y -- x x y ) >r dup r> ;
: 2drop ( a b -- ) drop drop ;
: 3drop ( x y z -- ) drop drop drop ;
: over ( x y -- x y x ) dupd swap ;
: keep ( ..a x quot: ( ..a x -- ..b ) -- ..b x ) over [ call ] dip ;
: 2keep ( ..a x y quot: ( ..a x y -- ..b ) -- ..b x y ) [ 2dup ] dip 2dip ;
: bi ( x p q -- ) [ keep ] dip call ;
: tri ( x p q r -- ) [ [ keep ] dip keep ] dip call ;
: pick ( x y z -- x y z x ) >r over r> swap ;
: bi* ( x y p q -- ) [ dip ] dip call ;
: bi@ ( x y quot -- ) dup bi* ;
! deprecated ones
: rot ( x y z -- y z x ) >r swap r> swap ;
: -rot ( x y z -- z x y ) swap >r swap r> ;
: spin ( x y z -- z y x ) swap rot ;
: tuck ( x y -- y x y ) swap over ;
! mine
: 2swap ( a b x y -- x y a b ) [ -rot ] dip -rot ;

: uncount ( countedstr -- str len ) dup getbyte [ 1 + ] dip ;

! print byte array
: print_bytes ( str len -- ) [ dup getbyte emit 1 + ] times drop ;

! print counted string
: print ( countedstr -- ) uncount print_bytes ;

! call pred until it returns f
: loop ( ... pred: ( ... -- ... ? ) -- ... ) dup >r call [ r> loop ] [ r> drop ] if ;
: times ( ... n quot: ( ... -- ... ) -- ... ) swap dup 0 = [ 2drop ] [ [ [ call ] keep ] dip 1 - swap times ] if ;
: each-integer ( ... n quot: ( ... i -- ... ) -- ... ) swap 0 swap [ [ swap call ] 2keep 1 + ] times 2drop ;
: do ( pred body -- pred body ) dup 2dip ;
: while ( ..a pred: ( ..a -- ..b ? ) body: ( ..b -- ..a ) -- ..b ) over [ call ] 2dip rot [ over [ call ] 2dip while ] [ 2drop ] if ;
: until ( ..a pred: ( ..a -- ..b ? ) body: ( ..b -- ..a ) -- ..b ) over [ call ] 2dip rot [ 2drop ] [ over [ call ] 2dip until ] if ;

! specialized version of each for byte arrays and strings
: _each-step ( ... addr quot: ( ... x -- ... ) -- ... addr+1 quot ) 2dup [ [ getbyte ] dip call ] 2dip [ 1 + ] dip ;
: ba-each ( ... seq quot: ( ... x -- ... ) -- ... ) [ uncount ] dip swap [ _each-step ] times 2drop ;
! parsing word
SYNTAX: \ ( -- quot type ) token find [ 3 suffix ] [ _bad-input ] if ;

: . ( thing -- ) pwrite nl ;
: .x ( thing -- ) pwritex nl ;

! compare first char of string
: starts-with? ( countedstr char -- ? ) swap 1 + getbyte = ;

! acc in this context means reverse-vector on stack, consisting of item/type pairs and a count which always sits on top

! If string is a valid number literal, it is converted to a number, otherwise search for a word named by the string.
: parse-datum ( string  -- word/number type ) find [ dup _quot>> prim? [ _quot>> 0 ] [ 2 ] if ] [ parsenum [ 3 ] [ "parsing '" print print "' failed\! " print error ] if ] if ;
: scan-datum ( -- item type ) token parse-datum ;

: execute ( word -- effect ) _quot>> call ;
: parse-until-step ( acc end -- acc ? ) scan-datum dup 2 = [ rot pick _name>> swap starts-with? [ 2drop f ] [ over parsing-word? [ drop execute t ] [ [ _quot>> ] dip suffix t ] if ] if ] [ [ drop ] 2dip suffix t ] if ; 
: parse-until ( acc end -- acc ) [ parse-until-step ] keep swap [ parse-until ] [ drop ] if ;

! loop until token (char for now)
! caveat: eats up complete token!
: scan-until-char ( char quot: ( tok -- ) -- )  swap [ token swap 2dup starts-with? [ drop f ] [ [ swap [ call ] keep ] dip t ] if ] loop 2drop ;

! convert tos to inst
: inst ( inst -- ) cell 1 - 8 * neg shift 0xff bitand ;

: prim? ( address -- ? ) inst instbase >= ;

! "parse accumulator" on the stack

! add element to parsed stuff on stack, name taken from factor, but not completely correct
: suffix ( ..item/types count item type -- ..item/types item type newcount ) rot 1 + ;

! quotations on the stack
! put element on the stack along with word type information: 0: instruction, 1: short jump, 2: long jump, 3: long literal, 4: byte literal, 5: ref, 6: nop

! return size of word when stored in quotation
: _wordsize ( type -- size ) dup 0 = [ drop 1 ] [ dup 1 = [ drop 3 ] [ dup [ 2 = ] [ 5 = ] bi or [ drop cell 1 + ] [ dup 3 = [ drop cell 1 + ] [ dup 4 = [ 2 ] [ 6 = [ 0 ] [ "size for item unknown" print error ] if ] if ] if ] if ] if ] if ;

: -q, ( item type -- ) dup 0 = [ drop inst -b, ] [ dup 1 = [ drop -s, oplit bcall inst -b, ] [ dup 2 = [ drop -, oplit acall inst -b, ] [ dup [ 3 = ] [ 5 = ] bi or [ drop -, oplit lit inst -b, ] [ 6 = [ drop ] [ "compilation for item unknown" print error ] if ] if ] if ] if ] if ;

! compile parser accumulator to memory
: _stack2code ( acc -- ) _MP get + [ _MP set ] keep [ [ -q, ] times ] with-MP ;

! box types: 1: string/byte-array , 2: word, 3: vector, 4: variable, 5: ref

! put quotation head to memory
: _qhead, ( blength -- ) 2 s, 0 b, b, ;

! determine size of quotation accumulated, careful: not tail recursive, return stack must be able to hold number of elements, retain stack must hold twice the number of elements in accumulator
! reminder: acc === .. item type n
: _accum-quotation-size-worker ( acc x -- acc x ) over 0 = not [ pick _wordsize + rot >r rot >r [ 1 - ] dip _accum-quotation-size-worker [ 1 + ] dip r> -rot r> -rot ] when ;
: _accum-quotation-size ( acc -- acc x ) 0 _accum-quotation-size-worker ;

! check if quotation on stack is valid, if yes, save to memory and return saved address
: >quotation ( acc -- addr ) [ oplit qend 0 ] dip 1 + _accum-quotation-size dup 255 > [ error ] [ dup _qhead, ] if _MP get [ _stack2code ] dip ;

: ] ( -- ) "unmatched ] " print error ;

! read in quotation, return address !
SYNTAX: [ ( -- ) 0 ']' parse-until >quotation 5 suffix ;
! read in quotation, compile to memory, create dictionary entry

: _strhead, ( blength -- ) 1 s, 1 b, b, ;

! accumulate bytes on stack (expensive, but hey)
: _readstr ( -- ..bytes num ) 0 [ receive dup 34 = [ drop f ] [ swap 1 + t ] if ] loop ;
: _stack2string ( ..bytes num ) dup _MP get + [ _MP set ] keep [ [ -b, ] times ] with-MP ;
SYNTAX: " ( -- countedstring" )  _readstr [ _strhead, ] keep _MP get [ _stack2string ] dip 1 - 3 suffix ;

! copy token to memory since it will be overridden by following parsing
: _token2str ( token -- addr ) uncount dup _strhead, _MP get [ [ dup getbyte b, 1 + ] times drop ] dip 1 - ;

! helper
: read-token ( -- string ) token _token2str ;

: strlen ( str -- n ) getbyte ;

! count reaching 0 means all matched
: mem= ( a1 a2 n -- ? ) dup 0 = [ 3drop t ] [ -rot 2dup [ getbyte ] bi@ = [ [ 1 + ] bi@ rot 1 - mem= ] [ 3drop f ] if ] if ;
: str= ( str1 str2 -- ? ) dup strlen 1 + mem= ;
: cstr-print ( cstr -- ) [ dup getbyte dup 0 = not ] [ emit 1 + ] while ;
: cstr-dp ( cstr str -- ) "comparing str: '" print print "' to cstr: '" print cstr-print "'" print nl ;
! compare read token to header name, problem: name has terminal 0 byte which must not be checked
: name= ( name str -- ? ) swap [ uncount ] bi@ [ swap ] dip 1 - over = [ mem= ] [ 3drop f ] if ;

! name of dict entry
: _name>> ( dictentry -- str ) cell + 1 + ;
: parsing-word? ( dictentry -- ? ) cell + get 0x01 bitand ;
: _dict-next ( dictentry -- dictentry ) _name>> dup strlen + 1 + ;
: _quot>> ( dictentry -- quot ) get ;

! check if both quotations return true
! : is-both? ( x q1 q2 -- ? ) bi@ and ;
! check if at lease one quotation returns true
! : is-one? ( x q1 q2 -- ? ) bi@ or ;

! this version returns the header!
! : _find_header ( str dictionary -- dictentry/str ? ) swap over _name>> dup strlen 0 = [ drop swap drop f ] [ over name= [ drop t ] [ swap _dict-next _find_header ] if ] if ;
! : _find_header ( str dictionary -- dictentry/str ? ) [ [ _name>> [ [ strlen 0 = ] [ ] is-both? ] keep
: _find-header ( str dictionary -- dictentry/str ? ) dup _name>> dup strlen 0 = [ 2drop f ] [ pick name= [ nip t ] [ _dict-next _find-header ] if ] if ;
: find ( str -- dictentry/str ? ) dictstart _find-header ;

: ; ( -- ) "unexpected semicolon " print error ;

! colon compiler
SYNTAX: : ( -- ) token _token2str 0 ';' parse-until >quotation swap name ;

SYNTAX: \! ( -- ) [ receive 10 = [ f ] [ t ] if ] loop ;
SYNTAX: ( ( -- ) [ receive 41 = [ f ] [ t ] if ] loop ;
SYNTAX: B{ ( -- addr ) 0 '}' [ parsenum [ swap 1 + ] [ "not a byte literal: " print print error ] if ] scan-until-char dup _strhead, _MP get [ _stack2string ] dip 1 - 3 suffix ;

! dictionary usage
: dsize ( -- ) dictend dictstart - _free-name dictstart - ;

: testloop ( -- ) [ '\!' emit t ] loop ;
