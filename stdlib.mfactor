! -*- mode: factor -*-
! top level loop
: top ( -- ) _test1 _init_storage listener ;

: t ( -- t ) 1 ;
: f ( -- f ) 0 ;

! some unit tests
: _test1 ( -- ) [ [ 'a' emit ] 'b' emit call ] call _test2 _test3 nl _test4 _test5 ;
: _test2 ( -- ) 'c' emit [ f ] loop ;
: _test3 ( -- ) 5 [ dup '0' + emit 1 - dup ] loop drop ;
: _test4 ( -- ) 254 memstart setbyte 175 memstart 1 + setbyte memstart get .x ;
: _test5 ( -- ) [ "tests done." print ] call nl ;

! listener
: unknown-token ( tok -- ) parsenum [ nop ] [ _bad-input ] if ;
: listener ( -- ) prompt token find [ call ] [ unknown-token ] if listener ;
: prompt ( -- ) psplevel pwrite '>' emit ' ' emit ;
: nl ( -- ) 10 emit ;
: _bad-input ( input -- ) drop 'X' dup '_' swap emit emit emit nl ;

: and ( obj1 obj2 -- ? ) over ? ;
: or ( obj1 obj2 -- - ) dupd ? ;
: not ( ? -- \? ) 0 1 ? ;

: >= ( n1 n2 -- ? ) 2dup > [ 2drop t ] [ = ] if ;
: in-range ( val start end -- ? ) [ over [ >= ] dip ] dip < and ;

! unsafe access
: getmem ( addr -- ) _get ;
: getmem8 ( addr -- ) _getbyte ;

: setmem ( val addr -- ) _set ;
: setmem8 ( val addr -- ) _setbyte ;

! safe access
! : _safeset ( value address setter: ( val addr -- ) -- ) [ dup memrange [ 2drop ] 2dip in-range ] dip swap  [ call ] [ 3drop "safe set failed" print error ] if ;
! use same memory range constraint as read for now
: _safeset ( value address setter: ( val addr -- ) -- ) [ dup memrange 2drop in-range ] dip swap  [ call ] [ 3drop "safe set failed" print error ] if ;
: setbyte ( byteval addr -- ) [ _setbyte ] _safeset ;
: set ( val addr -- ) [ _set ] _safeset ;

: _safeget ( address getter: (addr -- val ) -- val ) [ dup memrange 2drop in-range ] dip swap [ call ] [ 2drop "safe get failed" print error ] if ;
: getbyte ( addr -- byteval ) [ _getbyte ] _safeget ;
: get ( addr -- val ) [ _get ] _safeget ;

! memory pointers:
! MP: make pointer for comma operations, also pointing into data memory for allocation
! DP: data pointer pointing into empty data memory, for allocation
: _init_storage ( -- ) memstart cell + _MP set ;
! : _DP ( -- DP ) memstart cell + ;
: _MP ( -- MP ) memstart ;

: showmem ( -- ) memstart _MP get [ 2dup >= [ f ] [ [ dup getbyte .x 1 + ] dip t ] if ] loop 2drop ;

: _dprint ( c name -- c ) print ": " print dup .x ;
! find next free dictionary entry (check for first name byte = 0)
! dict_entry layout: addr(4)|flag(1)|namelength(1)|name(namelength)
: _free-name ( -- addr ) dictstart [ cell + 1 + dup getbyte [ + 1 + ] keep 0 = not ] loop cell - 2 - ;

! save quotation in dictionary, non-immediate
: name ( quot name -- ) _free-name [ swap , 0 b, uncount dup b, [ dup getbyte b, 1 + ] times drop ] with-MP ;

! apply q to var's value and update var
: change ( var q: ( old -- new ) -- ) [ [ get ] keep ] dip dip set ;
! incf var
: +@ ( n var -- ) [ + ] change ;

: shift ( x n -- y ) dup 0 > [ asl ] [ neg asr ] if ;

! temporarily different memory pointer
: with-MP ( addr quot -- ) swap _MP get [ _MP set call ] dip _MP set ;

! compile reverse
: b, ( byteval -- ) _MP [ get setbyte ] [ 1 swap +@ ] bi ;
: -b, ( byteval -- ) _MP [ 1 neg swap +@ ] [ get setbyte ] bi ;
! ! compile short to mem, little endian
: s, ( short -- ) dup b, 8 neg shift b, ;
: -s, ( short -- ) dup 8 neg shift -b, -b, ;
! compile cell
: , ( val -- ) cell [ dup b, 8 neg shift ] times drop ;
: -, ( val -- ) cell [ cell 1 - neg + 8 * over swap shift -b, ] each-integer drop ;

: square ( x -- xÂ² ) dup * ;

: if ( cond true false -- true/false ) ? call ;
: when ( ..a ? true: ( ..a -- ..a ) -- ..a ) [ nop ] if ;

! some stack shufflers and combinators
: nip ( x y - y ) swap drop ;
: dip ( x quot -- x ) swap >r call r> ;
: 2dip ( x y quot -- x y ) swap [ dip ] dip ;
: 3dip ( x y z quot -- x y z ) swap [ 2dip ] dip ;
: 2dup ( a b  -- a b a b ) over over ;
: dupd ( x y -- x x y ) >r dup r> ;
: 2drop ( a b -- ) drop drop ;
: 3drop ( x y z -- ) drop drop drop ;
: over ( x y -- x y x ) dupd swap ;
: keep ( ..a x quot: ( ..a x -- ..b ) -- ..b x ) over [ call ] dip ;
: 2keep ( ..a x y quot: ( ..a x y -- ..b ) -- ..b x y ) [ 2dup ] dip 2dip ;
: bi ( x p q -- ) [ keep ] dip call ;
: tri ( x p q r -- ) [ [ keep ] dip keep ] dip call ;
: pick ( x y z -- x y z x ) >r over r> swap ;
! deprecated ones
: rot ( x y z -- y z x ) >r swap r> swap ;
: -rot ( x y z -- z x y ) swap >r swap r> ;
: spin ( x y z -- z y x ) swap rot ;
: tuck ( x y -- y x y ) swap over ;
! mine
: 2swap ( a b x y -- x y a b ) [ -rot ] dip -rot ;

: uncount ( countedstr -- str len ) dup getbyte [ 1 + ] dip ;

! print byte array
: print_bytes ( str len -- ) [ dup getbyte emit 1 + ] times drop ;

! print counted string
: print ( countedstr -- ) uncount print_bytes ;

! call pred until it returns f
: loop ( ... pred: ( ... -- ... ? ) -- ... ) dup >r call [ r> loop ] [ r> drop ] if ;
: times ( ... n quot: ( ... -- ... ) -- ... ) swap dup 0 = [ 2drop ] [ [ [ call ] keep ] dip 1 - swap times ] if ;
: each-integer ( ... n quot: ( ... i -- ... ) -- ... ) swap 0 swap [ [ swap call ] 2keep 1 + ] times 2drop ;
! : while ( pred:( ..a -- ..b ?) body:( ..b -- ..a) -- ..b) over [ call ] 2keep [ swap [ call ]] [] if

! parsing word
SYNTAX: \ ( -- quot ) token find [ nop ] [ _bad-input ] if ;

: . ( thing -- ) pwrite nl ;
: .x ( thing -- ) pwritex nl ;

! compare first char of string
: starts-with? ( countedstr char -- ? ) swap 1 + getbyte = ;

! loop until token (char for now)
! TODO: support parsing words here!!!
: until-token ( char quot: ( tok -- ) -- )  swap [ token swap 2dup starts-with? [ drop f ] [ [ swap [ call ] keep ] dip t ] if ] loop 2drop ;

! convert tos to inst
: inst ( inst -- ) cell 1 - 8 * neg shift 0xff bitand ;

: prim? ( address -- ? ) inst instbase >= ;

! quotations on the stack
! put element on the stack along with word type information: 0: instruction, 1: short jump, 2: long jump, 3: long literal, 4: byte literal

! deprecated
! : _q+ ( ..item/itype num item itype -- ..item/itype new-item new-itype num+1 ) rot 1 + ;

: _qstacksize ( type -- size )  dup 0 = [ drop 1 ] [ dup 1 = [ drop 3 ] [ dup 2 = [ drop cell 1 + ] [ dup 3 = [ drop cell 1 + ] [ 4 = [ 2 ] [ error ] if ] if ] if ] if ] if ;

: -q, ( item type -- ) dup 0 = [ drop -b, ] [ dup 1 = [ drop -s, oplit bcall inst -b, ] [ dup 2 = [ drop -, oplit acall inst -b, ] [ 3 = [ -, oplit lit inst -b, ] [ error ] if ] if ] if ] if ;

! compile number of words to memory words: ( word type ), update _MP
: _stack2code ( ..item/itype num size -- ) _MP get + [ _MP set ] keep [ [ -q, ] times ] with-MP ;

! sequence head types: 1: string, 2: quotation, 3: vector, anything above INSTBASE is an extended type

! put quotation head to memory TODO!!
: _qhead, ( blength -- ) 2 s, 0 b, b, ;

! find word for compilation in quotation, return type suitable for _qstacksize
: _find_qword ( token -- item type ) find [ dup prim? [ inst 0 ] [ 2 ] if ] [ parsenum [ 3 ] [ error ] if ] if ;

! scan input stream until closing ']', accumulate item type pairs and total size in bytes on stack
: _readq ( separator -- ..item/types num size ) 0 0 ']' [ _find_qword dup _qstacksize [ 2swap ] dip + [ 1 + ] dip ] until-token [ oplit qend inst 0 ] 2dip [ 1 + ] dip 1 + ;

! return address of quotation, not header!
SYNTAX: [ ( -- addr) _readq dup 255 > [ error ] [ dup _qhead, ] if _MP get [ _stack2code ] dip ;

: _strhead, ( blength -- ) 1 s, 1 b, b, ;

! accumulate bytes on stack (expensive, but hey)
: _readstr ( -- ..bytes num ) 0 [ receive dup 34 = [ drop f ] [ swap 1 + t ] if ] loop ;
: _stack2string ( ..bytes num ) dup _MP get + [ _MP set ] keep [ [ -b, ] times ] with-MP ;
SYNTAX: " ( -- countedstring" )  _readstr [ _strhead, ] keep _MP get [ _stack2string ] dip 1 - ;

SYNTAX: \! ( -- ) [ receive 10 = [ f ] [ t ] if ] loop ;

! dictionary usage
: dsize ( -- ) dictend dictstart - _free-name dictstart - ;

: testloop ( -- ) [ '\!' emit t ] loop ;
