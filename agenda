- DONE name table
- DONE name lookup
- DONE basic repl
- DONE proper tail calls
- DONE add primitives for allocating stuff in data mem
- DONE add allocating stuff in dictionary
- DONE untangle build system
- DONE sequence allocation
  - DONE: current scheme of directly increasing DP doesnt support
    nesting, replace with atomic allocation after read
- DONE: dictionary extension, DEFERRED: namestack
- DONE: apply counted strings to token reader
- DONE: reader nesting, involves making parsing explicit
- DONE: > remove dict entries and substitute with offset number from known ff-pointer array
    to allow for quick runtime word lookup (constant time)
- DONE: revamp ruby compiler, with dictionary support and syntax error reporting
- DONE: implement new literals
- DONE: compilation to graphs, inline recursive words not working yet
- DONE: inlining tail recursive combinators
- DONE: get rid of phi functions in generated cdfg (happens when phi'd data is requested)
- insert dummy nodes at ends of conditional branches, _before_
  returning to main code.  This should fix empty branches not being
  registered as then or else nodes.  Alternatively, retroactively mark
  branches as then or else when returning from an if and creating the
  join.  This needs some stack inspection
- pull any and all type definition or inference out of the emitter code into the analyzer (stack checker)
- in c_emitter, unify handling of node representation. Either generate as needed, or pre-generate everything,
  but not both (as currently)
- split mfactor code into platform dependent and platform independent parts
- handle constants like functions regarding application overrides
- demote ruby vocab loader to bootstrapping, switching to
  parsing primitives after base system is loaded.  This might incur a
  performance hit, depending on how Parslet's performance compares to
  forward parsing using generated image.
- maybe move unique name generation into CDFG's realm, emitter only needs to query names
- ensure that mutual tail-recursive combinators work
- support non-tail-recursive combinators (involves generating an
  "anonymous" function for every usage of the combinator), also
  support no-inlining of combinators when stack effects are given
- stopworld compacting precise mark-sweep gc (should only be triggered during user input,
  so not time critical)

