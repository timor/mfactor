# top ( .. )
top: [ :bcall, :_test1, :bcall, :_init_storage, :btcall, :listener ]
#top: [ :bcall, :_test1, :btcall, :listener ]

_test1: [ :qstart, :qstart, :litb, "a", :emit, :qend, :litb, "b", :emit, :stcall, :qend, :stcall, :bcall, :_test2, :bcall, :_test3]
_test2: [ :litb, "c", :emit, :qstart, :bcall, :f, :qend, :bcall, :loop]
_test3: [ :litb, 5, :qstart, :dup, :litb, "0", :add, :emit, :one, :sub, :dup, :qend, :btcall, :loop, :drop ]

# listener ( -- )
# prompt token find [ call ] [ unkown-token ] if listener
listener: [ :bcall, :prompt, :token, :find, :oplit, :scall, :blitq, :unknown-token, :bcall, :if, :btcall, :listener ]

# ( obj1 obj2 -- ? )
# over ?
and: [ :bcall, :over, :truefalse ]

# ( obj1 obj2 -- ? )
# dupd ?
or: [ :bcall, :dupd, :truefalse ]

# ( ? -- \? )
# 0 1 ?
not: [ :zero, :one, :truefalse ]

# ( n1 n2 -- ? )
# 2dup > [ 2drop t ] [ = ] if
">=": [ :bcall, :over, :bcall, :over, :gt, :qstart, :drop, :drop, :btcall, :t, :qend, :oplit, :eql, :btcall, :if ]

# test if value is in range, including start but excluding stop
# ( val start end -- ? )
# [ over [ >= ] dip ] dip < and
in-range: [ :qstart, :bcall, :over, :blitq, :">=", :btcall, :dip, :qend, :bcall, :dip, :lt, :btcall, :and ]

# TODO: remove f as return value, implement proper exception handling

# safe memory manipulation
# ( value address setter: (val addr -- ) -- )
# [ dup memrange [ 2drop ] 2dip in-range ] dip swap [ call ] [ 3drop f ] if
_safeset: [ :qstart, :dup, :memrange, :qstart, :drop, :drop, :qend, :bcall, :2dip, :btcall, :in-range, :qend, :bcall, :dip, :swap, :oplit, :stcall, :qstart, :bcall, :3drop, :error, :qend, :btcall, :if ]

#( byteval addr -- )
setbyte: [ :oplit, :_setbyte, :btcall, :_safeset ]
#( val addr -- )
set: [ :oplit, :_set, :btcall, :_safeset ]

# safe memory get
# ( address getter: (addr -- val ) -- val )
# [ dup memrange 2drop in-range ] dip swap [ call ] [ 2drop f ] if
_safeget: [ :qstart, :dup, :memrange, :drop, :drop, :btcall, :in-range, :qend, :bcall, :dip, :swap, :oplit, :stcall, :qstart, :drop, :drop, :error, :qend, :btcall, :if ]

#( addr -- byteval )
getbyte: [ :oplit, :_getbyte, :btcall, :_safeget ]
#( addr -- val )
get: [ :oplit, :_get, :btcall, :_safeget ]

# set the first word in memory as the memory write pointer (_MP)
# set the second word in memory as the dictionary write pointer (_NP)
# ( -- )
# memstart cell + _MP set
_init_storage: [ :memstart, :cellsize, :add, :bcall, :_MP, :bcall, :set ]

# next free memory address ( -- _MP)
_MP: [ :memstart ]

# next name entry - search for string with length 0
# dictstart [ cell + dup getbyte [ + 1 + ] keep 0 = not ] loop cell - 1 -
next-name: [ :dictstart, :qstart, :cellsize, :add, :dup, :bcall, :getbyte, :qstart, :add, :one, :add, :qend, :bcall, :keep, :zero, :eql, :btcall, :not, :qend, :bcall, :loop, :cellsize, :sub, :one, :sub ]

# combinator: bind value to different val during quotation evaluation

# apply quotation to variable's value, update
# ( var quot: ( old -- new ) -- )
#  [ [ get ] keep ] dip dip set
change: [ :qstart, :blitq, :get, :bcall, :keep, :qend, :bcall, :dip, :bcall, :dip, :btcall, :set ]

# add n to the variable's value
# ( n var -- )
# [ + ] change
"+@": [ :oplit, :add, :btcall, :change ]

# ( byteval -- )
# _MP [ get setbyte ] [ 1 swap +@ ] bi
"b,": [ :bcall, :_MP, :qstart, :bcall, :get, :btcall, :setbyte, :qend, :qstart, :one, :swap, :btcall, :"+@", :qend, :btcall, :bi ]

# bitwise shifting x by n
# ( x n .. y )
# dup 0 > [ asl ] [ neg asr ] if
shift: [ :dup, :zero, :gt, :oplit, :asl, :qstart, :neg, :asr, :qend, :btcall, :if ]

# ( val -- )
# setbyte does the masking already
# cell [ dup b, -8 shift ] times drop
",": [ :cellsize, :qstart, :dup, :bcall, :"b,", :litb, 8, :neg, :btcall, :shift, :qend, :bcall, :times, :drop  ]

# (prompt) ( -- )
prompt: [ :psplevel, :pwrite, :litb, '>', :emit, :litb, ' ', :emit ]

# ( x -- x^2 )
square: [ :dup, :mul ]

# ( cond true false -- [effect] )
if: [ :truefalse, :stcall ]

# ( input -- )
bad-input: [ :drop, :litb, "\n", :litb, 'X', :dup, :litb, '_', :swap, :emit, :emit, :emit, :emit ]

# ( x y -- y )
nip: [ :swap, :drop ]

# ( x quot -- x)
dip: [ :swap, :to_r, :scall, :r_from ]

# ( x y quot -- x y )
# swap [ dip ] dip
2dip: [ :swap, :blitq, :dip, :btcall, :dip ]

# ( x y -- x x y )
dupd: [ :to_r, :dup, :r_from ]

# ( x y z -- )
3drop: [ :drop, :drop, :drop ]

# ( x y -- x y x )
over: [ :bcall, :dupd, :swap ]

# ( ..a x quot: ( ..a x -- ..b ) -- ..b x )
keep: [ :bcall, :over, :oplit, :scall, :btcall, :dip ]

# [ 2dup ] dip 2dip
2keep: [ :qstart, :bcall, :over, :bcall, :over, :qend, :bcall, :dip, :btcall, :2dip ]

# ( x p q -- )
# [ keep ] dip call
bi: [ :blitq, :keep, :bcall, :dip, :stcall ]

# tri ( x p q r -- )
# [ [ keep ] dip keep ] dip call
tri: [ :qstart, :blitq, :keep, :bcall, :dip, :btcall, :keep, :qend, :bcall, :dip, :stcall ]

# ( pred quot -- pred quot )
do: [ :dup, :btcall, :2dip ]

# ( quot:( -- ? ) -- [effect] )
# stops when ? is false
# dup >r call [ r> loop ] [ r> drop ] if
loop: [ :dup, :to_r, :scall, :qstart, :r_from, :btcall, :loop, :qend, :qstart, :r_from, :drop, :qend, :btcall, :if ]

# ( n quot -- )
# swap dup 0 = [ 2drop ] [ [ [ call ] keep ] dip 1 - swap times ] if
# TODO maybe rewrite using loop and composition/currying
# times: [ :swap, :dup, :litb, 0, :eql, :qstart, :drop, :drop, :qend, :qstart, :qstart, :oplit, :stcall, :btcall, :keep, :qend, :bcall, :dip, :litb, 1, :sub, :swap, :btcall, :times, :qend, :btcall, :if ]
# swap dup 0 = [ 2drop ] [ >r dup >r call r> r> 1 - swap times ] if
times: [ :swap, :dup, :zero, :eql, :qstart, :drop, :drop, :qend, :qstart, :to_r, :dup, :to_r, :scall, :r_from, :r_from, :one, :sub, :swap, :btcall, :times, :qend, :btcall, :if ]


# ( -- quot )
"\\": [ :token, :find, :oplit, :nop, :blitq, :bad-input, :btcall, :if ]

# ( q1 q2 -- q1q2 )
compose: [ ]

# ( pred:( ..a -- ..b ?) body:( ..b -- ..a) -- ..b)
while: [ :bcall, :over, :scall, :qstart, :qend, :qstart, :qend, :btcall, :if ]

# colon compiler
":": [ ]

# ( tok -- )
unknown-token: [ :parsenum, :oplit, :nop, :blitq, :bad-input, :btcall, :if ]

.: [ :pwrite, :litb, "\n", :emit ]

# ( -- next_free_name )

t: [ :one ]
f: [ :zero ]

testloop: [ :qstart, :litb, "!", :emit, :btcall, :t, :qend, :btcall, :loop ]
