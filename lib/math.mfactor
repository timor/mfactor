!-*- mode: factor -*-


! basic arithmetic and logic operations

: shift ( x n -- y ) dup 0 > [ asl ] [ neg asr ] if ;

: >= ( n1 n2 -- ? ) 2dup > [ 2drop t ] [ = ] if ;

! start inclusive, end exclusive
: in-range ( val start end -- ? ) [ over [ >= ] dip ] dip < and ;

: t ( -- t ) 1 ;
: f ( -- f ) 0 ;

: and ( obj1 obj2 -- ? ) over ? ;
: or ( obj1 obj2 -- - ) dupd ? ;
: not ( ? -- \? ) 0 1 ? ;

: square ( x -- xÂ² ) dup * ;

: each-integer ( ... n quot: ( ... i -- ... ) -- ... ) swap 0 swap [ [ swap call ] 2keep 1 + ] times 2drop ;

! copied some math words from factor
: _if-iterate? ( i n true false -- ) [ 2over < ] 2dip if ;
: _iterate-step ( i n quot -- i n quot ) [ nip call ] 3keep ;
: _iterate-rot ( ? i n quot -- i n quot ? ) [ rot ] dip swap ;
: _iterate-next ( i n quot -- i' n quot ) [ 1 + ] 2dip ;
! slightly different than in factor: return additional flag marking if found, otherwise leave next number
: _(find-integer) ( ... i n quot: ( ... i -- ... ? ) -- ... i ? )
    [
        _iterate-step _iterate-rot
        [ 2drop t ] [ _iterate-next _(find-integer) ] if
    ] [ 2drop f ] _if-iterate? ;
: _iterate-prep ( n quot -- i n quot ) [ 0 ] 2dip ;
: find-integer ( ... n quot: ( ... i -- ... ? ) -- ... i ? ) _iterate-prep _(find-integer) ;

! quotations on the stack
! put element on the stack along with word type information: 0: instruction, 1: short jump, 2: long jump, 3: long literal, 4: byte literal, 5: ref, 6: nop

: ] ( -- ) "unmatched ] " print error ;

! read in quotation, return address !
SYNTAX: [ ( -- ) 0 "]" parse-until >quotation 5 suffix ;
! read in quotation, compile to memory, create dictionary entry


! copy token to memory since it will be overridden by following parsing
: _token2str ( token -- addr ) uncount dup _strhead, _MP get [ [ dup getbyte b, 1 + ] times drop ] dip 1 - ;

! helper
: read-token ( -- string ) token _token2str ;

! comments
SYNTAX: \! ( -- ) [ receive 10 = [ f ] [ t ] if ] loop ;
SYNTAX: ( ( -- ) [ receive 41 = [ f ] [ t ] if ] loop ;




