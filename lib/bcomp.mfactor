!-*- mode: factor -*-
USING: kernel memory math io parser vocabs headers ;
IN: bcomp

! byte code compiler functions

! compilation, reverse
: -b, ( byteval -- ) _MP [ 1 neg swap +@ ] [ get setbyte ] bi ;
! ! compile short to mem, little endian
: -s, ( short -- ) dup 8 neg shift -b, -b, ;
! compile cell
: -, ( val -- ) cell [ cell 1 - neg + 8 * over swap shift -b, ] each-integer drop ;

: _-q, ( item type -- ) dup 0 = [ drop _inst -b, ] [ dup 1 = [ drop -s, oplit bcall _inst -b, ] [ dup 2 = [ drop -, oplit acall _inst -b, ] [ dup [ 3 = ] [ 5 = ] bi or [ drop -, oplit lit _inst -b, ] [ 6 = [ drop ] [ "compilation for item unknown" print error ] if ] if ] if ] if ] if ;

! compile parser accumulator to memory
: _stack2code ( acc -- ) _MP get + [ _MP set ] keep [ [ _-q, ] times ] with-MP ;

! return size of word when stored in quotation
: _wordsize ( type -- size ) dup 0 = [ drop 1 ] [ dup 1 = [ drop 3 ] [ dup [ 2 = ] [ 5 = ] bi or [ drop cell 1 + ] [ dup 3 = [ drop cell 1 + ] [ dup 4 = [ 2 ] [ 6 = [ 0 ] [ "size for item unknown" print error ] if ] if ] if ] if ] if ] if ;

! determine size of quotation accumulated, careful: not tail recursive, return stack must be able to hold number of elements, retain stack must hold twice the number of elements in accumulator
! reminder: acc === .. item type n
: _accum-quotation-size-worker ( acc x -- acc x ) over 0 = not [ pick _wordsize + rot >r rot >r [ 1 - ] dip _accum-quotation-size-worker [ 1 + ] dip r> -rot r> -rot ] when ;
: _accum-quotation-size ( acc -- acc x ) 0 _accum-quotation-size-worker ;

! check if accumulator contains valid quotation, if yes, save to memory and return saved address
: >quotation ( acc -- addr ) [ oplit qend 0 ] dip 1 + _accum-quotation-size dup 255 > [ error ] [ dup _qhead, ] if _MP get [ _stack2code ] dip ;

: ; ( -- ) "unexpected semicolon " print error ;

! copy token to memory since it will be overridden by following parsing
: _token2str ( token -- addr ) uncount dup _strhead, _MP get [ [ dup getbyte b, 1 + ] times drop ] dip 1 - ;

! helper
: read-token ( -- string ) token _token2str ;

! colon compiler
SYNTAX: : ( -- ) read-token 0 B{ 59 } parse-until >quotation swap [ dup search nip [ "re" print ] when "defining: " print print nl ] keep name ;

! accumulate bytes on stack (expensive, but hey)
: _readstr ( -- ..bytes num ) 0 [ receive dup 34 = [ drop f ] [ swap 1 + t ] if ] loop ;
! allocate memory and copy bytes
: _stack2string ( ..bytes num -- ) dup _MP get + [ _MP set ] keep [ [ -b, ] times ] with-MP ;
SYNTAX: " ( -- countedstring" )  _readstr [ _strhead, ] keep _MP get [ _stack2string ] dip 1 - 5 suffix ;
SYNTAX: B{ ( -- addr ) 0 "}" [ parsenum [ swap 1 + ] [ "not a byte literal: " print print error ] if ] scan-until-str dup _strhead, _MP get [ _stack2string ] dip 1 - 5 suffix ;

: ] ( -- ) "unmatched ] " print error ;

! read in quotation, return address !
SYNTAX: [ ( -- ) 0 "]" parse-until >quotation 5 suffix ;
! read in quotation, compile to memory, create dictionary entry
