!-*- mode: factor -*-
USING: kernel memory math io parser vocabs headers ;
IN: bcomp

! byte code compiler functions

! compilation, reverse
: -b, ( byteval -- ) _MP [ 1 neg swap +@ ] [ get setbyte ] bi ;
! ! compile short to mem, little endian
: -s, ( short -- ) dup 8 neg shift -b, -b, ;
! compile cell
: -, ( val -- ) cell [ cell 1 - neg + 8 * over swap shift -b, ] each-integer drop ;

! take an item/type pair from the parser accumulator, compile the correct quotation element
! for type information, see parser vocabulary
! TODO: user ref instructions!
: _-q, ( item type -- ) dup 0 = [ drop _inst -b, ]
    [ dup 1 = [ drop -s, oplit bcall _inst -b, ]
      [ dup 2 = [ drop -, oplit acall _inst -b, ]
        [ dup [ 3 = ] [ 5 = ] bi or [ drop -, oplit liti _inst -b, ]
          [ 6 = [ drop ] [ "compilation for item unknown" print error ] if ] if ] if ] if ] if ;

! compile parser accumulator to memory
: _stack2code ( acc -- ) _MP get + [ _MP set ] keep [ [ _-q, ] times ] with-MP ;

! return size of word when stored in quotation
: _wordsize ( type -- size ) dup 0 = [ drop 1 ] [ dup 1 = [ drop 3 ] [ dup [ 2 = ] [ 5 = ] bi or [ drop cell 1 + ] [ dup 3 = [ drop cell 1 + ] [ dup 4 = [ 2 ] [ 6 = [ 0 ] [ "size for item unknown" print error ] if ] if ] if ] if ] if ] if ;

! determine size of quotation accumulated, careful: not tail recursive, return stack must be able to hold number of elements, retain stack must hold twice the number of elements in accumulator
! reminder: acc === .. item type n
: _accum-quotation-size-worker ( acc x -- acc x ) over 0 = not [ pick _wordsize + rot >r rot >r [ 1 - ] dip _accum-quotation-size-worker [ 1 + ] dip r> -rot r> -rot ] when ;
: _accum-quotation-size ( acc -- acc x ) 0 _accum-quotation-size-worker ;

! check if accumulator contains valid quotation, if yes, save to memory and return saved address
: >quotation ( acc -- addr ) [ oplit qend 0 ] dip 1 + _accum-quotation-size dup 255 > [ error ] [ dup _qhead, ] if _MP get [ _stack2code ] dip ;

: ; ( -- ) "unexpected semicolon " print error ;

! copy token to memory since it will be overridden by following parsing
: _token2str ( token -- addr ) uncount dup _strhead, _MP get [ [ dup getbyte b, 1 + ] times drop ] dip 1 - ;

! helper
: read-token ( -- string ) token _token2str ;

! colon compiler
! read in name and quotation, compile to memory, create dictionary entry
SYNTAX: : ( -- ) read-token 0 B{ 59 } parse-until >quotation swap [ dup search nip [ "re" print ] when "defining: " print print nl ] keep name ;

! accumulate bytes on stack (expensive, but hey)
: _readstr ( -- ..bytes num ) 0 [ receive dup 34 = [ drop f ] [ swap 1 + t ] if ] loop ;
! allocate memory and copy bytes, return address of count byte in header!
: _stack2string ( ..bytes num -- address )
    [ _strhead, ] keep
    _MP get [ over +
        [ [ -b, ] times ] with-MP ] keep 1 - ;
: _read-string-and-compile ( acc -- acc )
    _readstr _stack2string 5 suffix ;
SYNTAX: " ( acc -- acc" ) _read-string-and-compile ;
SYNTAX: B{ ( acc -- acc ) 0 "}" [ parsenum [ swap 1 + ] [ "not a byte literal: " print print error ] if ] scan-until-str _stack2string 5 suffix ;

: ] ( -- ) "unmatched ] " print error ;

! Read in quotation, return address and type.  Creates new accumulator, parses until
! quotation end, saves that accum to memory and adds a reference to that to the old accum
SYNTAX: [ ( acc -- acc ) 0 "]" parse-until >quotation 5 suffix ;
