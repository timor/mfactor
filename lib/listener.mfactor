!-*- mode: factor -*-

! listener, the interactive frontend

: nl ( -- ) 10 emit ;

: _bad-input ( input -- ) drop 'X' dup '_' swap emit emit emit nl ;

: unknown-token ( tok -- ) parsenum [ nop ] [ _bad-input ] if ;

: prompt ( -- ) psplevel pwrite '>' emit ' ' emit ;

: listener ( -- ) prompt token search [ dup parsing-word? [ _quot>> 0 swap call [ drop ] times ]
                                        [ _quot>> call ] if ] [ unknown-token ] if listener ;
: . ( thing -- ) pwrite nl ;
: .x ( thing -- ) pwritex nl ;
: bits ( -- const ) cell 8 * ;
: .b ( n -- ) bits [ [ 8 mod 0 = [ 32 emit ] when ] keep bits swap - 1 - neg over swap shift 0x1 bitand 0x30 + emit ] each-integer nl drop ;

! "parse accumulator" on the stack
! acc in this context means reverse-vector on stack, consisting of item/type pairs and a count which always sits on top

! add element to parsed stuff on stack, name taken from factor, but not completely correct
: suffix ( ..item/types count item type -- ..item/types item type newcount ) rot 1 + ;

SYNTAX: \ ( -- quot type ) token search [ 3 suffix ] [ _bad-input ] if ;

! If string is a valid number literal, it is converted to a number, otherwise search for a word named by the string.
: parse-datum ( string  -- word/number type )
    search [ dup _quot>> prim? [ _quot>> 0 ] [ 2 ] if ]
    [ parsenum [ 3 ] [ "parsing '" print print "' failed\! " print error ] if ] if ;
: scan-datum ( -- item type ) token parse-datum ;

: execute ( word -- effect ) _quot>> call ;
: parse-until-step ( acc end -- acc ? ) scan-datum dup
    2 = [ rot pick _name>> name= [ 2drop f ]
          [ over parsing-word? [ drop execute t ]
            [ [ _quot>> ] dip suffix t ] if ] if ]
            [ [ drop ] 2dip suffix t ] if ;
: parse-until ( acc end -- acc ) [ parse-until-step ] keep swap [ parse-until ] [ drop ] if ;

! loop until token matches str
: scan-until-str ( str quot: ( tok -- ) -- )  swap [ token swap 2dup str= [ drop f ] [ [ swap [ call ] keep ] dip t ] if ] loop 2drop ;


