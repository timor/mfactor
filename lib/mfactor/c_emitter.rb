require 'mfactor/graph'

module MFactor
  # C Code generation: take a CDFG work through it. CDFG already has
  # inputs, literals, call results, outputs as data nodes, and
  # Start/End markers, join nodes (for loop-backward jumps)
  # and choice nodes (if/then branch points).  The first output gets
  # passed as return value, the other outputs are returned in pointer
  # parameters.  Code generation works by successively stepping from
  # start to end node.  When encountering a function call, all input
  # data dependencies are reverse-DFS'd and emitted if necessary,
  # recording a name for the specific item.  Join nodes are
  # emitted as do {} while constructs, choice nodes are emitted as if-then-else
  # constructs.  Control edges towards a join node are emitted as
  # goto's.  It should be possible to emit all backwards jumps as
  # whiles, since this is really the only construct that can be
  # generated by the analyzer.
  #
  # The initialization argument points to a hash (intended to be
  # created from a YAML file) which contains all associatons from not
  # trivially mapped primitive words, and also other words if
  # requested, to application-specific c functions. Format:
  #   mfactor-name: [c-name,arity]

  class CEmitter
    @@constant_builtins = [ "cell", "memstart", "memend", "dictstart", "dictend","instbase" ]
    @@binary_builtins = {
      "+" => "+","-" => "-","*" => "*","/" => "/", "asr" => ">>",
      "asl" => "<<", "mod" => "%", "bitand" => "&", "bitor" => "|",
      "bitxor" => "^", "and" => "&&", "or" => "||", ">" => ">", "<" => "<",
      "=" => "==", "<=" => "<=", ">=" => ">=" }
    @@unary_builtins = {"not" => "!", "bitnot" => "~", "getmem" => "*", "getmem8" => "*","neg" => "-"}
    @@custom_builtins = { 
      "?" => proc {|cond,then_alt,else_alt| cond+" ? "+then_alt+" : "+else_alt},
      "setmem" => proc {|value, address| "*#{address} = #{value}"},
      "setmem8" => proc {|value, address| "*#{address} = #{value}"}, # WARNING: COPIED
      "pwrite"=> proc {|args| "printf(\"%d\",#{args[0]})"},
      "pwritex"=> proc {|args| "printf(\"%x\",#{args[0]})"},
      "nop" => proc{|args| ""}
    }
    @user_overrides = {}
    def initialize (user_overrides)
      if user_overrides
        puts "user overrides: #{user_overrides}" if user_overrides
        @user_overrides=user_overrides
      end
    end
    def out (str)
      @io << str
    end
    def line str
      @io << "\n" << str
    end
    def statement (str)
      @statements << ((" " * 2 * @block_stack.length) << str)
    end
    def declaration (str)
      @declarations << str
    end
    def in_block block
      @block_stack.push block
      yield
      @block_stack.pop
    end
    def emit(definition,io)
      @emitted=[]               # keeps track of all emitted nodes to avoid endless recursion
#      @names={}           # local variable and formal parameter names in this definition
      @declarations=[]    # collected declarations are emitted first
      @statements=[]      # collected statemets are emmited afterwards
      @d=definition       # definition being emitted
      @g=definition.graph # shortcut to graph of definition being emitted
      @io=io                    # io handle which every method can output to
      @block_stack=[]           # keeps track of nested blocks
      puts "emitting code for #{@d.name}"
      puts "formals: ",@g.inputs
      outs=@g.outputs.dup
      # puts "output: ",outs
      ret=nil
      unless outs.empty?
        ret=outs.shift
      end
      # emit header
      rtype = ret ? ret.type : 'void'
      line "#{rtype} #{MFactor::c_escape(@d.name)}("
      out (@g.inputs+outs).map{|a| format_definition_param(a)}.join(", ")
      out ") {"
      in_block @do do
        follow_control @g.start
        # if there are any assigned literals, define them first
        declare_assigned_literals # TODO: replace with general declaration statement
        @declarations.each {|d| line d }
        # actual body emitted here
        @statements.each {|s| line s }
      end
      line "}\n"
    end
    # Backwards jumps can assign data to literal numbers.  These are
    # usually loop counters.  These are substituted by initialized variables.
    def declare_assigned_literals
      @g.nodes.select {|n| n.is_a? MFIntLit}.each do |lit|
        unless @g.data_predecessors(lit).empty? # TODO make data_pred... private
          if lit.is_a? MFIntLit
            type="int32_t"
          else
            type="int8_t"
          end
          name=get_name(OpenStruct.new(name: "i"))
          declaration "#{type} #{name} = #{lit.value};"
        end
      end
    end
    # generates represenatation of function definition formal parameters
    def format_definition_param(item)
      res = ""
      res << item.type.to_s << " "
      if item.class == Output
        res << "* "
      end
      res << get_name(item)
      return res
    end
    # generates representation of function call arguments
    def format_call_argument(item)        # WARNING: COPIED CODE
      return (item.class == Output ? "&" : "" )+get_representation(item)
    end    # follows control path, emits on the way
    def get_override_representation(name, inputs)
      rep = if @user_overrides[:functions] and @user_overrides[:functions][name]
              puts "user function override"
              fname, arity = @user_overrides[:functions][name]
              fname+"("+inputs[0..arity-1].join(", ")+")"
            elsif @@constant_builtins.member? name
              puts "constant override"
              raise "constant cannot have arguments" unless inputs.empty?
              name.upcase
            elsif @@binary_builtins[name]
              puts "binary override"
              inputs.join(" "+@@binary_builtins[name]+" ")
            elsif @@unary_builtins[name]
              puts "unary override"
              raise "unary operator called with too many actuals" unless inputs.length == 1
              @@unary_builtins[name]+inputs[0]
            elsif @@custom_builtins[name]
              puts "custom override: #{@@custom_builtins[name]}"
              self.instance_exec(inputs, &@@custom_builtins[name])
            else
              nil
            end
      if rep
        "("+rep+");"
      else
        puts "no rep found"
        nil
      end
    end
    def follow_control(node)    # returns false if node was already visited
      if @emitted.member? node
        puts "have been here, returning node: #{node.object_id}"
        return node
      end
      puts "following control: #{node.class}"
      @emitted.push node
      case node
      when StartNode then
        return follow_control node.control_out
      when NopNode then
        return follow_control node.control_out
      when MFCompiledCall then  # emit function call, follow body
        call = node
        outs = call.outputs.dup
        actuals = call.inputs
        s=""
        if !outs.empty?         # TODO: check here if only one result and used exactly once. If so, do not generate statement but store call as inline representation
          s << get_name(outs.shift)+" = "
        end
        maybe_override = get_override_representation(call.definition.name, actuals.map{|i| get_representation(i)})
        if maybe_override
          s << maybe_override
        else
          raise "no override defined for primitive: #{call.definition.name}" if call.definition.primitive? and
            !maybe_override
          s << MFactor::c_escape(call.definition.name)+"("
          s << (actuals+outs).map{|a| format_call_argument(a)}.join(", ")
          s << ");"
        end
        statement s
        return follow_control(call.control_out)
      when LoopJoinNode then    # open a do-while construct
        puts "following down loop recursion path from #{node.object_id}"
        statement "do {"
        @block_stack.push node
        return follow_control node.control_out
      when IfJoinNode then      # just return the join, gets recorded for comparison
        puts "reached join: #{node.object_id}"
        return node
      when ChoiceNode then      # either close a do-while construct or emit an if-then-else
        # if then or else control target is join node, close a do-while block with the condition
        condition = get_representation(node)
        b1, b2 = @g.control_out_edges node
        if (b1[2] == :break) or (b2[2] == :break) # if any branch is a break branch, bail out here
          loop_rest, break_branch = b1, b2
          unless break_branch[2] == :break
            loop_rest, break_branch = break_branch, loop_rest
          end
          prefix = (loop_rest[2] == :then ? "!" : "")
          statement "if (#{prefix}#{condition}) break ;"
          join = @block_stack.last
          puts "following feedback path"
          fb_control = follow_control(loop_rest[1])
          puts "fb stopped at #{fb_control.object_id}"
          unless join.is_a? JoinNode and join == fb_control
            raise "trying to recurse out of non-do-while block!"
          end
          @block_stack.pop
          statement "} while(1);"
          return follow_control break_branch[1]
        else                    # normal split case
          then_edge, else_edge = b1, b2
          unless then_edge[2] == :then
            then_edge, else_edge = else_edge, then_edge
          end
          statement "if ("+condition+"){"
          join=nil
          in_block node do
            join=follow_control then_edge[1]
          end
          puts "then path join: "+join.object_id.to_s
          raise "then-control path did not end at join" unless join.is_a? JoinNode
          statement "} else {"
          elsejoin=nil
          in_block node do
            elsejoin=follow_control else_edge[1]
            puts "else path join: "+elsejoin.object_id.to_s
            raise "then and else paths did not meet at same join" unless join == elsejoin
          end
          statement "}"
          # if the join is a loop starting join, return it, otherwise continue after the join
          if join.is_a? LoopJoinNode
            return join
          else
            return follow_control join.control_out
          end
        end
      when EndNode then 
        return node
      else
        raise "No Emitter implemented for #{node} (#{node.class})"
      end
      raise "Congratulations, you just saved the continuation and bailed out"
    end
    def get_representation(element)
      # TODO: if element is only used once, generate inline call instead of temporary variable
      get_name element
    end
    def get_name(element)
      unless element.symbol
        raise "item not yet named: #{element.inspect}"
        # @names[element] = MFactor::c_escape(element.name)+@uid.succ!
      end
      element.symbol
    end
  end
end
