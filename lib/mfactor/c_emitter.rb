require 'mfactor/graph'

module MFactor
  # C Code generation: take a CDFG work through it. CDFG already has
  # inputs, literals, call results, outputs as data nodes, and
  # Start/End markers, join nodes (for loop-backward jumps)
  # and choice nodes (if/then branch points).  The first output gets
  # passed as return value, the other outputs are returned in pointer
  # parameters.  Code generation works by successively stepping from
  # start to end node.  When encountering a function call, all input
  # data dependencies are reverse-DFS'd and emitted if necessary,
  # recording a name for the specific item.  Join nodes are
  # emitted as do {} while constructs, choice nodes are emitted as if-then-else
  # constructs.  Control edges towards a join node are emitted as
  # goto's.  It should be possible to emit all backwards jumps as
  # whiles, since this is really the only construct that can be
  # generated by the analyzer.
  #
  # The initialization argument points to a hash (intended to be
  # created from a YAML file) which contains all associatons from not
  # trivially mapped primitive words, and also other words if
  # requested, to application-specific c functions. Format:
  #   mfactor-name: [c-name,arity]

  class CEmitter
    @@constant_builtins = [ "cell", "memstart", "memend", "dictstart", "dictend","instbase" ]
    @@binary_builtins = {
      "+" => "+","-" => "-","*" => "*","/" => "/", "asr" => ">>",
      "asl" => "<<", "mod" => "%", "bitand" => "&", "bitor" => "|",
      "bitxor" => "^", "and" => "&&", "or" => "||", ">" => ">", "<" => "<",
      "=" => "=="}
    @@unary_builtins = {"not" => "!", "bitnot" => "~", "getmem" => "*", "getmem8" => "*","neg" => "-"}
    @@custom_builtins = { 
      "?" => proc {|cond,then_alt,else_alt| cond+" ? "+then_alt+" : "+else_alt},
      "setmem" => proc {|value, address| "*#{address} = #{value}"},
      "setmem8" => proc {|value, address| "*#{address} = #{value}"}, # WARNING: COPIED
      "pwrite"=> proc {|args| "printf(\"%d\",#{args[0]})"},
      "pwritex"=> proc {|args| "printf(\"%x\",#{args[0]})"},
      "nop" => proc{|args| ""}
    }
    @user_overrides = {}
    def initialize (user_overrides)
      if user_overrides
        puts "user overrides: #{user_overrides}" if user_overrides
        @user_overrides=user_overrides
      end
    end
    def out (str)
      @io << str
    end
    def line (str="")
      @io << "\n" << (" " * 2 * @block_stack.length) << str
    end
    def in_block block
      @block_stack.push block
      yield
      @block_stack.pop
    end
    def emit(definition,io)
      @emitted=[]               # keeps track of all emitted nodes to avoid endless recursion
#      @names={}           # local variable and formal parameter names in this definition
      @d=definition       # definition being emitted
      @g=definition.graph # shortcut to graph of definition being emitted
      @io=io                    # io handle which every method can output to
      @block_stack=[]           # keeps track of nested blocks
      puts "emitting code for #{@d.name}"
      puts "formals: ",@g.inputs
      outs=@g.outputs.dup
      # puts "output: ",outs
      ret=nil
      unless outs.empty?
        ret=outs.shift
      end
      # emit header
      rtype = ret ? ret.type : 'void'
      line "#{rtype} #{MFactor::c_escape(@d.name)}("
      out (@g.inputs+outs).map{|a| format_definition_param(a)}.join(", ")
      out ") {"
      in_block @do do
        # if there are any assigned literals, define them first
        declare_assigned_literals # TODO: replace with general declaration statement
        # actual body code generated here
        follow_control @g.start
      end
      line "}\n"
    end
    # Backwards jumps can assign data to literal numbers.  These are
    # usually loop counters.  These are substituted by initialized variables.
    def declare_assigned_literals
      @g.nodes.select {|n| n.is_a? MFIntLit}.each do |lit|
        unless @g.data_predecessors(lit).empty?
          if lit.is_a? MFIntLit
            type="int32_t"
          else
            type="int8_t"
          end
#          name=@names[lit]
          name=lit.symbol
          line "#{type} #{name} = #{lit.value};"
          # @names[lit]=name
        end
      end
    end
    # generates represenatation of function definition formal parameters
    def format_definition_param(item)
      res = ""
      res << item.type.to_s << " "
      if item.class == Output
        res << "* "
      end
      res << get_name(item)
      return res
    end
    # generates representation of function call arguments
    def format_call_argument(item)        # WARNING: COPIED CODE
      return (item.class == Output ? "&" : "" )+get_representation(item)
    end    # follows control path, emits on the way
    def get_override_representation(name, inputs)
      rep = if @user_overrides[:functions] and @user_overrides[:functions][name]
              puts "user function override"
              fname, arity = @user_overrides[:functions][name]
              fname+"("+inputs[0..arity-1].join(", ")+")"
            elsif @@constant_builtins.member? name
              puts "constant override"
              raise "constant cannot have arguments" unless inputs.empty?
              name.upcase
            elsif @@binary_builtins[name]
              puts "binary override"
              inputs.join(" "+@@binary_builtins[name]+" ")
            elsif @@unary_builtins[name]
              puts "unary override"
              raise "unary operator called with too many actuals" unless inputs.length == 1
              @@unary_builtins[name]+inputs[0]
            elsif @@custom_builtins[name]
              puts "custom override: #{@@custom_builtins[name]}"
              self.instance_exec(inputs, &@@custom_builtins[name])
            else
              nil
            end
      if rep
        "("+rep+");"
      else
        puts "no rep found"
        nil
      end
    end
    def follow_control(node)    # returns false if node was already visited
      if @emitted.member? node
        puts "have been here, returning node"
        return node
      end
      puts "following control: #{node}"
      @emitted.push node
      case node
      when StartNode then
        return follow_control node.control_out
      when MFCompiledCall then  # emit function call, follow body
        call = node
        outs = call.outputs.dup
        # puts "call inputs: #{call.inputs}"
        # puts "call outputs: #{outs}"
        actuals = call.inputs
        # puts "call actuals: #{actuals}"  # could actually be more than one, so not using!
        line
        if !outs.empty?
          out get_name(outs.shift)+" = "
        end
        maybe_override = get_override_representation(call.definition.name, actuals.map{|i| get_representation(i)})
        if maybe_override
          out maybe_override
        else
          raise "no override defined for primitive: #{call.definition.name}" if call.definition.primitive? and
            !maybe_override
          out MFactor::c_escape(call.definition.name)+"("
          out (actuals+outs).map{|a| format_call_argument(a)}.join(", ")
          out ");"
        end
        return follow_control(call.control_out)
      when LoopJoinNode then    # open a do-while construct
        puts "following down loop recursion path"
        line "do {"
        @block_stack.push node
        return follow_control node.control_out
      when IfJoinNode then      # just record node, follow_control will return false
                                # when join node is visited the second time
        puts "reached join"
        return node
      when ChoiceNode then      # either close a do-while construct or emit an if-then-else
        # if then or else control target is join node, close a do-while block with the condition
        condition = get_representation(node)
        if node.jump            # loop case
          feedback = (node.jump == :else)? node.else_edge[1] : node.then_edge[1]
          cont = (node.jump == :else)? node.then_edge[1] : node.else_edge[1]
          prefix = node.jump == :then ? "" : "!"
          join = @block_stack.pop
          puts "following feedback path"
          unless join.is_a? JoinNode and join == follow_control(feedback)
            raise "trying to recurse out of non-do-while block!"
          end
          line "} while(#{prefix}#{condition});"
          return follow_control cont
        else                    # normal split case
          line "if ("+condition+"){"
          join=nil
          in_block node do
            join=follow_control node.then_edge[1]
          end
          raise "then-control path did not end at if-join" unless join.is_a? IfJoinNode
          line "} else {"
          in_block node do
            raise "then and else paths did not meet at same join" unless join == 
              follow_control(node.else_edge[1])
          end
          line "}"
          return follow_control join.control_out
        end
      when EndNode then 
        return node
      else
        raise "No Emitter implemented for #{node}"
      end
      raise "Congratulations, you just saved the continuation and bailed out"
    end
    def get_representation(element)
      # if element.is_a? MFIntLit
      #   if @names[element]
      #     @names[element]
      #   else
      #     element.value.to_s
      #   end
      # else
        get_name element
      # end
    end
    def get_name(element)
      unless element.symbol
        raise "item not yet named: #{element.inspect}"
        # @names[element] = MFactor::c_escape(element.name)+@uid.succ!
      end
      element.symbol
    end
  end
end
