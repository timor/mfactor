<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>MFactor Documentation</title>
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">MFactor Documentation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline18">1. Introduction</a>
<ul>
<li><a href="#orgheadline3">1.1. Usage Concept</a></li>
<li><a href="#orgheadline12">1.2. Contents</a>
<ul>
<li><a href="#orgheadline4">1.2.1. <code>html</code></a></li>
<li><a href="#orgheadline5">1.2.2. <code>lib</code></a></li>
<li><a href="#orgheadline6">1.2.3. <code>org</code></a></li>
<li><a href="#orgheadline9">1.2.4. <code>src</code></a>
<ul>
<li><a href="#orgheadline8">1.2.4.1. <code>mfactor</code></a></li>
</ul>
</li>
<li><a href="#orgheadline10">1.2.5. <code>tasks</code></a></li>
<li><a href="#orgheadline11">1.2.6. <code>test</code></a></li>
</ul>
</li>
<li><a href="#orgheadline13">1.3. Configuring the Rake Task</a></li>
<li><a href="#orgheadline14">1.4. Generated Output Files</a></li>
<li><a href="#orgheadline15">1.5. Making Existing C Functions Available</a></li>
<li><a href="#orgheadline16">1.6. Basic MFactor concepts</a></li>
<li><a href="#orgheadline17">1.7. Differences to Factor</a></li>
</ul>
</li>
<li><a href="#orgheadline7">2. <span class="todo nilTODO">TODO</span> Supplied Libraries</a>
<ul>
<li><a href="#orgheadline19">2.1. <span class="todo nilTODO">TODO</span> Listener</a></li>
</ul>
</li>
<li><a href="#orgheadline1">3. Host Compiler</a>
<ul>
<li><a href="#orgheadline20">3.1. Concept</a></li>
<li><a href="#orgheadline21">3.2. <span class="todo nilTODO">TODO</span> Parser details</a></li>
<li><a href="#orgheadline22">3.3. Bytecode Generator Output</a></li>
<li><a href="#orgheadline23">3.4. Invocation</a></li>
<li><a href="#orgheadline24">3.5. <span class="todo nilTODO">TODO</span> Compilation example</a></li>
<li><a href="#orgheadline26">3.6. Details</a>
<ul>
<li><a href="#orgheadline25">3.6.1. Fried Quotations(WIP)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline2">4. VM Implementation</a>
<ul>
<li><a href="#orgheadline34">4.1. Definitions and Datatypes</a>
<ul>
<li><a href="#orgheadline29">4.1.1. Typedefs</a>
<ul>
<li><a href="#orgheadline27">4.1.1.1. Scalar Types</a></li>
<li><a href="#orgheadline28">4.1.1.2. Dictionary entries</a></li>
</ul>
</li>
<li><a href="#orgheadline30">4.1.2. Preprocessor Macros</a></li>
<li><a href="#orgheadline31">4.1.3. Defines for the generated data in <code>bytecode.c</code></a></li>
<li><a href="#orgheadline32">4.1.4. Internal Error Codes</a></li>
<li><a href="#orgheadline33">4.1.5. Main VM Function Prototype</a></li>
</ul>
</li>
<li><a href="#orgheadline35">4.2. Work Memory</a></li>
<li><a href="#orgheadline45">4.3. Special Variables</a>
<ul>
<li><a href="#orgheadline43">4.3.1. Special Variables Definition</a>
<ul>
<li><a href="#orgheadline36">4.3.1.1. <code>MP</code>: The Memory Write Pointer</a></li>
<li><a href="#orgheadline37">4.3.1.2. <code>HANDLER</code>: Current Exception handling frame</a></li>
<li><a href="#orgheadline38">4.3.1.3. <code>DEBUG_LEVEL</code>: VM Debug Verbosity</a></li>
<li><a href="#orgheadline39">4.3.1.4. <code>RESTART</code>: Restart address (deprecated)</a></li>
<li><a href="#orgheadline40">4.3.1.5. <code>STEP_HANDLER</code>: Single Stepping Handler (not in use)</a></li>
<li><a href="#orgheadline41">4.3.1.6. <code>BASE</code>: Current Segment base address</a></li>
<li><a href="#orgheadline42">4.3.1.7. <code>OUTPUT_STREAM</code>: Output Stream descriptor</a></li>
</ul>
</li>
<li><a href="#orgheadline44">4.3.2. Special Variables Initialization</a></li>
</ul>
</li>
<li><a href="#orgheadline51">4.4. Helper Funtions</a>
<ul>
<li><a href="#orgheadline46">4.4.1. Output Handling</a></li>
<li><a href="#orgheadline47">4.4.2. Return Stack Entry Format</a></li>
<li><a href="#orgheadline48">4.4.3. Word Lookup: Dictionary support</a></li>
<li><a href="#orgheadline49">4.4.4. Parsing Numbers</a></li>
<li><a href="#orgheadline50">4.4.5. Debug output</a></li>
</ul>
</li>
<li><a href="#orgheadline59">4.5. Used Subroutines (defined as Macros)</a>
<ul>
<li><a href="#orgheadline52">4.5.1. Backtrace printing</a></li>
<li><a href="#orgheadline53">4.5.2. Errors during primitive execution</a></li>
<li><a href="#orgheadline54">4.5.3. Stack Operation Assertion</a></li>
<li><a href="#orgheadline58">4.5.4. Stack operations</a>
<ul>
<li><a href="#orgheadline55">4.5.4.1. Data Stack (Parameter Stack)</a></li>
<li><a href="#orgheadline56">4.5.4.2. Return Stack</a></li>
<li><a href="#orgheadline57">4.5.4.3. Retain Stack</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline82">4.6. Main Interpreter function <code>interpreter()</code></a>
<ul>
<li><a href="#orgheadline65">4.6.1. Internal State Definition</a>
<ul>
<li><a href="#orgheadline60">4.6.1.1. Stacks</a></li>
<li><a href="#orgheadline61">4.6.1.2. Program counter</a></li>
<li><a href="#orgheadline62">4.6.1.3. Tail Call Optimization</a></li>
<li><a href="#orgheadline63">4.6.1.4. Helper "Register"</a></li>
<li><a href="#orgheadline64">4.6.1.5. Debug Mode</a></li>
</ul>
</li>
<li><a href="#orgheadline68">4.6.2. State initialization</a>
<ul>
<li><a href="#orgheadline66">4.6.2.1. Output File Descriptor</a></li>
<li><a href="#orgheadline67">4.6.2.2. Special Variable Initalization</a></li>
</ul>
</li>
<li><a href="#orgheadline81">4.6.3. Primitive Instructions</a>
<ul>
<li><a href="#orgheadline69">4.6.3.1. Basic stack manipulation</a></li>
<li><a href="#orgheadline70">4.6.3.2. Arithmetic Instructions</a></li>
<li><a href="#orgheadline71">4.6.3.3. Constants</a></li>
<li><a href="#orgheadline72">4.6.3.4. Access to Internal Constants</a></li>
<li><a href="#orgheadline73">4.6.3.5. Access to Internal State</a></li>
<li><a href="#orgheadline74">4.6.3.6. Literal Instructions</a></li>
<li><a href="#orgheadline75">4.6.3.7. IO Primitives</a></li>
<li><a href="#orgheadline76">4.6.3.8. Call/Return Instructions</a></li>
<li><a href="#orgheadline77">4.6.3.9. Conditional</a></li>
<li><a href="#orgheadline78">4.6.3.10. Memory Access</a></li>
<li><a href="#orgheadline79">4.6.3.11. Foreign Function Execution</a></li>
<li><a href="#orgheadline80">4.6.3.12. (As of Yet) Undocumented instructions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline85">5. Appendix: Complete Sources</a>
<ul>
<li><a href="#orgheadline83">5.1. interpreter.h</a></li>
<li><a href="#orgheadline84">5.2. interpreter.c</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
MFactor is a (partial) implementation of the <a href="http://factorcode.org/">factor language</a> for embedded systems.
It consists of two parts:
</p>

<ol class="org-ol">
<li>A <b>host compiler</b>, written in Ruby, which is used with the <a href="https://github.com/ruby/rake">Rake</a> build system to produce a
binary image (see <a href="#orgheadline1">Host Compiler</a>).</li>

<li>A <b>c implementation of a bytecode vm</b> which is able to execute such an image. (see <a href="#orgheadline2">VM Implementation</a>)</li>
</ol>

<p>
It is intended to be used with a embedded C development environment, where its sources are
compiled together with the host application.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.1</span> Usage Concept</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The general idea: First compile .mfactor source files to bytecode image, then compile the
provided c source files together with the host application's source files into the final binary.
</p>

<div class="figure">
<p><img src="img/concept.png" alt="concept.png" />
</p>
</div>

<p>
A set of mfactor source files is translated by the host compiler (called through rake task
<code>mfactor</code>) into a bytecode image.  This bytecode image is then successively executed by
<code>interpeter()</code>, which is the actual VM implementation.
</p>

<p>
In order to incorporate this into a project, several rake tasks are supplied in <a href="../tasks/mfactor.rake">tasks/mfactor.rake</a>
</p>

<ul class="org-ul">
<li><b>mfactor</b>: the main task, which, when called, generates above code</li>
<li><b>mftest[word name]</b>: helper task, outputs a graphical representation of a specific word in the <code>generated</code> subdir.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">1.2</span> Contents</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Description of files and directories.
</p>
<dl class="org-dl">
<dt><code>Gemfile[.lock]</code></dt><dd>Ruby packages version, see ruby gems documentation</dd>
<dt><code>Rakefile</code></dt><dd>for mfactor development only</dd>
<dt><code>instructionset.yml</code></dt><dd>this file defines the primitive instructions for the <a href="#orgheadline2">VM
Implementation</a>.  Note that the host compiler gets its list of supported instructions
from <code>src/mfactor/primitives.mfactor</code>.</dd>
</dl>
</div>

<div id="outline-container-orgheadline4" class="outline-4">
<h4 id="orgheadline4"><span class="section-number-4">1.2.1</span> <code>html</code></h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
contains generated documentation
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-4">
<h4 id="orgheadline5"><span class="section-number-4">1.2.2</span> <code>lib</code></h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Ruby source code for the <a href="#orgheadline1">Host Compiler</a>.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6"><span class="section-number-4">1.2.3</span> <code>org</code></h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Source of this file
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">1.2.4</span> <code>src</code></h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
Contains the target-independend C source, some linker files and the supplied MFActor
libraries (see <a href="#orgheadline7">2</a>)
</p>

<dl class="org-dl">
<dt><code>interpreter.[ch]</code></dt><dd>source of the <a href="#orgheadline2">VM Implementation</a></dd>
<dt><code>reader.c</code></dt><dd>simple tokenizer implementation</dd>
<dt><code>seq_headers.h</code></dt><dd>definitions for inline data headers(e.g. used by <code>litc</code> in <a href="#orgtarget1">4.6.3.6</a></dd>
</dl>

<p>
The following headers have target-dependent implementations in <code>target/</code>
</p>
<dl class="org-dl">
<dt><code>reset_system.h</code></dt><dd>toggle system/interpreter reset</dd>
<dt><code>runtime.h</code></dt><dd>platform-specifics for measuring run times</dd>
</dl>
</div>

<div id="outline-container-orgheadline8" class="outline-5">
<h5 id="orgheadline8"><span class="section-number-5">1.2.4.1</span> <code>mfactor</code></h5>
<div class="outline-text-5" id="text-1-2-4-1">
<p>
Supplied MFactor libraries (see <a href="#orgheadline7">2</a>).
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10"><span class="section-number-4">1.2.5</span> <code>tasks</code></h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
<code>mfactor.rake</code>: The file that defines the <code>mfactor</code> rake task that is used to integrate
the VM into the host application (see <a href="#orgtarget2">1.3</a>)
</p>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">1.2.6</span> <code>test</code></h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
Ruby unit tests
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.3</span> Configuring the Rake Task<a id="orgtarget2"></a></h3>
<div class="outline-text-3" id="text-1-3">
<p>
The rake file is supposed to be included with rake's <code>import</code> facility in the host
application's own Rakefile.
</p>

<p>
Currently, it is configured via setting global variables in the including rake file.
The following must be set:
</p>
<ul class="org-ul">
<li><code>MFACTOR_SRC_DIR</code>: Determines the directory where the application's mfactor sources can
be found.  This should point to the application's mfactor source directory.</li>
<li><code>GENERATOR</code>: which bytecode backend to use, currently, only <code>Cortex</code> is supported</li>
<li><code>START_WORD</code>: word, which will be executed when starting the vm</li>
<li><code>MFACTOR_ROOT_VOCAB</code>: The root vocabulary, which is first loaded and loads all
dependencies.  Must be found in <code>MFACTOR_SRC_DIR</code>.</li>
<li><code>MFACTOR_DEPENDING_OBJECTS</code>: To cause Rake to recompile the whole image, this
should be set to the object files in the application which depend on the generated
output. This usually means all files that use any of the words defined in
<code>MFACTOR_C_WORDS</code>, as well as the object file that is built from <code>src/interpreter.c</code></li>
</ul>

<p>
The following are for advanced functionality:
</p>
<ul class="org-ul">
<li><p>
<code>MFACTOR_C_WORDS</code>: Hashtable for exposing word locations in bytecode to C. Format:
</p>
<div class="org-src-container">

<pre class="src src-ruby">{ <span style="color: #8b2252;">"mfactor-word-name"</span> =&gt; <span style="color: #8b2252;">"NAME_OF_CPP_DEFINE"</span> }
</pre>
</div>
<p>
This can be used to generate preprocessor symbols, which can be passed directly to
<code>interpreter()</code>, for example.
</p></li>
<li><code>MFACTOR_FF</code>: path to file containing interface definitions to c code (see <a href="#orgtarget3">1.5</a>)</li>
<li><code>MFACTOR_IMAGE_SECTION</code>: a string describing the linker section that the bytecode-image
will pe placed into</li>
<li><code>MFACTOR_DICT_SECTION</code>: same thing for the generated dictionary</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">1.4</span> Generated Output Files</h3>
<div class="outline-text-3" id="text-1-4">
<p>
In the application's main directory, a directory <code>generated</code> is created during the build
process, where several files are generated:
</p>

<dl class="org-dl">
<dt><code>bytecode.c</code></dt><dd>main output from the ByteCodeImage class.</dd>
<dt><code>bytecode.h</code></dt><dd>consists of defines that <code>interpreter()</code> and maybe the user application
needs to know about</dd>
<dt><code>image.dump</code></dt><dd>after translation, the ByteCodeImage is written here using <a href="http://ruby-doc.org/core-2.2.3/Marshal.html">Marshal</a>.  It
can be reloaded later in the build process with <code>ByteCodeImage.deserialize</code> to
extract information about the image.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">1.5</span> Making Existing C Functions Available<a id="orgtarget3"></a></h3>
<div class="outline-text-3" id="text-1-5">
<p>
Special global variable <code>MFACTOR_FF</code> can be set to a yaml file for
"importing" existing c functions into the interpreter's namespace (Foreign function interface).
entries are in the form of:
</p>

<div class="org-src-container">

<pre class="src src-yaml"><span style="color: #a0522d;">&lt;c_name&gt;</span>:
  <span style="color: #a0522d;">name</span>: <span style="color: #8b2252;">"&lt;mfactor-name&gt;"</span>
  <span style="color: #a0522d;">call</span>: &lt;callspec&gt;
  <span style="color: #b22222;"># </span><span style="color: #b22222;">following optional line is for void functions, for functions returning a value, don't use</span>
  <span style="color: #a0522d;">result</span>: discard
</pre>
</div>

<p>
where <code>&lt;callspec&gt;</code> describes the function's arguments, e.g. "iis" for a function like <code>fn(int, int, int16)</code>.
Currently supported values are:
</p>
<ul class="org-ul">
<li><code>v</code> -&gt; fn(void)</li>
<li><code>lit</code> -&gt; for variables (returns their address)</li>
<li><code>s</code>, <code>i</code>, <code>b</code>, <code>bi</code>, <code>ib</code>, <code>is</code>, <code>ii</code>, <code>iis</code>, <code>iii</code> where <code>i</code> is <code>int</code>, <code>b</code> is <code>int8</code> and <code>s</code> is <code>int16</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16"><span class="section-number-3">1.6</span> Basic MFactor concepts</h3>
<div class="outline-text-3" id="text-1-6">
<p>
For the complete Factor language, see <a href="http://docs.factorcode.org/content/article-handbook-language-reference.html">the official documentation</a>.  The language is
<a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">concatenative</a>, and uses generally postfix syntax, e.g. the arguments are written before
the "function call".  <a href="http://concatenative.org/wiki/view/Concatenative%20language/Name%20code%20not%20values">This</a> provides a good introduction to the concepts of concatenative
languages.
</p>

<p>
Terminology:
</p>
<dl class="org-dl">
<dt>Word</dt><dd>the basic user-defined abstraction, like functions in most languages.</dd>
<dt>Parsing Word</dt><dd>defined by <code>SYNTAX:</code>, these take control of the parser if used
interactively, and are supported indepently of that by the byte-code compiler.</dd>
<dt>Vocabulary</dt><dd>comparable to C's compilation unit with interface definition in a header
file.  Contains a number of word definitions.</dd>
<dt>Data Stack</dt><dd>or Parameter Stack, holds values that are manipulated by words.</dd>
<dt>Return Stack</dt><dd>keeps track of program execution when calling into words and returning.
In contrast to Forth, not directly accessible by user code.</dd>
<dt>Retain Stack</dt><dd>second stack for data, which is used to set aside stack elements that
are needed for later.  Used internally by all <a href="http://docs.factorcode.org/content/article-dip-keep-combinators.html">preserving combinators</a>.</dd>
<dt>Quotation</dt><dd>block of code enclosed in square brackets (<code>[]</code>), that is pushed onto the
stack as-is, without evaluation.</dd>
<dt>Combinator</dt><dd><p>
word that takes quotations as input.  The conditional word <code>if</code> takes
a condition and 2 quotations as input:
</p>
<div class="org-src-container">

<pre class="src src-factor">condition-value [
    true-quotation
] [
    false-quotation
] if
</pre>
</div></dd>
<dt>Primitives</dt><dd>are the low-level instructions that are executed by the VM.  All words
are defined in terms of other words, some of them primitives.  The binary
representation of a word, however, consists entirely of primitives.</dd>
<dt>Image</dt><dd>is a (compiled) array of primitives, that constitutes the binary representation
of the mfactor source program</dd>
<dt>Dictionary</dt><dd>generated table that holds information on word definitions, most
prominently the address of the words's bytecode in the image</dd>
</dl>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17"><span class="section-number-3">1.7</span> Differences to Factor</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Mfactor implements a subset of factor's functionality useful for embedded systems programming.
Major differences:
</p>
<ul class="org-ul">
<li>no namestack, so no dynamic variables (may change, but high
performance impact for embedded systems)</li>
<li>vocabulary search is simplified, vocabulary <code>foo</code> would be found in
<code>&lt;MFACTOR_SRC_DIR&gt;/foo.mfactor</code>, vocabulary <code>foo.bar</code> would be found in
<code>&lt;MFACTOR_SRC_DIR&gt;/foo.bar.mfactor</code>.</li>
<li>same-named words in different vocabularies not supported (yet)</li>
<li>interactive support only for byte-array and integer-array sequences: <code>B{ }</code>, <code>I{ }</code>, at
compile time, arbitrary sequences can be used.</li>
<li>host compiler only supports a subset of parsing words: <code>:</code>, <code>SYNTAX:</code>, <code>{ }</code>, <code>B{ }</code>, <code>I{
  }</code>, `SYMBOLS:`, <code>USING:</code>, <code>IN</code></li>
<li><code>case</code> is implemented as a syntax word, so no interactive support</li>
<li>words beginning with underscore(<code>_</code>) are not stored in the dictionary.  This is intended
for helper functions, to prevent them from consuming dictionary space.</li>
<li>no continuations, no quotation compositions(yet)</li>
<li>simplified exception handling with `catch` and `throw`</li>
<li>no Garbage Collector.  Since interactive usage is meant to be for developing, allocated
objects by the reader are not released automatically.  Any data used in normal code is
statically compiled into the image, so no runtime allocation is performed unless
specified explicitely using sequence constructors <code>&lt;byte-array&gt;</code> and <code>&lt;integer-array&gt;</code></li>
<li>no object system, so the type of stack items can generally not be determined (with
exceptions.  If it is known to point to a sequence or other complex data structure,
information about the element types can be extracted)</li>
</ul>

<p>
<b>Practical Consequences:</b>
Most of the omissions are due to resource constraints in embedded systems, where runtime
allocation is generally not desirable.  The missing runtime type support has the following
main consequences:
</p>

<p>
When printing an object, it must be known what it is:
</p>
<ul class="org-ul">
<li><code>.</code>, <code>.x</code>, <code>.b</code> shows the raw value(decimal, hex, binary) of an item, if it is a number,
that is its value, if it is a sequence, it is the address of it's count byte</li>
<li><code>ba.x</code>, <code>ba.b</code> prints the elements of a byte-array (hex, binary).  If top of stack is
not a byte array, garbage is output.</li>
<li>generally (e.g. for integer arrays) normal iteration also works:
<code>some-integer-array [ . ] each</code></li>
</ul>

<p>
Not all sequence operations are type-independent (yet).
Support matrix:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">factor</th>
<th scope="col" class="org-left">mfactor general</th>
<th scope="col" class="org-left">mfactor for byte arrays</th>
<th scope="col" class="org-left">mfactor for integer arrays</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">nth</td>
<td class="org-left">nth</td>
<td class="org-left">ba-nth</td>
<td class="org-left">ia-nth</td>
</tr>

<tr>
<td class="org-left">set-nth</td>
<td class="org-left">N/A</td>
<td class="org-left">ba-set-nth</td>
<td class="org-left">ia-set-nth</td>
</tr>

<tr>
<td class="org-left">each</td>
<td class="org-left">each</td>
<td class="org-left">ba-each</td>
<td class="org-left">ia-each</td>
</tr>

<tr>
<td class="org-left">change-nth</td>
<td class="org-left">N/A</td>
<td class="org-left">ba-change-nth</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">find</td>
<td class="org-left">N/A</td>
<td class="org-left">ba-find</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">reduce</td>
<td class="org-left">reduce</td>
<td class="org-left">ba-reduce</td>
<td class="org-left">N/A</td>
</tr>

<tr>
<td class="org-left">each-index</td>
<td class="org-left">each-index</td>
<td class="org-left">N/A</td>
<td class="org-left">N/A</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">2</span> <span class="todo TODO">TODO</span> Supplied Libraries</h2>
<div class="outline-text-2" id="text-2">
<p>
A number of mfactor source files are supplied together with the VM, to provide the
(mainly) Factor-compatible functionality.  These are to be documented here.
</p>
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">2.1</span> <span class="todo TODO">TODO</span> Listener</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Add control flow example using the listener.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">3</span> Host Compiler</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20"><span class="section-number-3">3.1</span> Concept</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The host compiler scans <code>MFACTOR_SRC_DIR</code> for the vocabulary specified with
<code>MFACTOR_ROOT_VOCAB</code>, and loads it.  When loading a vocabulary, it searches it's own
mfactor sources and the files in <code>MFACTOR_SRC_DIR</code> for a file named
<code>&lt;vocab-name&gt;.mfactor</code>.  It recursively loads any formerly unloaded vocabularies in the
process.  Loading a vocabulary involves following ruby classes:
</p>

<div class="figure">
<p><img src="img/rbcomp.png" alt="rbcomp.png" />
</p>
</div>

<p>
The Parser reads the source code, checking for syntax errors and generating an internal
representation of the code.  Once all the words have been loaded, the internal <code>Image</code>
object is turned into a <code>ByteCodeImage</code> object, which is the main output product.
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21"><span class="section-number-3">3.2</span> <span class="todo TODO">TODO</span> Parser details</h3>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22"><span class="section-number-3">3.3</span> Bytecode Generator Output</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Per default, the output of the rake task is place in subdirectory <code>generated</code> of the
including project.  This folder contains several files:
</p>
<ul class="org-ul">
<li><code>inst_enum.h</code> - enum which contains all instruction mnemonics.  These are used in the
image generated in =bytecode.c"</li>
<li><code>mfactor_words.h</code> - contains all exported words, which can then be referenced from C
context.</li>
<li><code>bytecode.c</code> - contains the actual byte code image, dictionary and hash table</li>
<li><code>bytecode.h</code> - some constants which are generated during byte code compilation and
used in the VM implementation</li>
<li><code>image.dump</code> - serialized MFactor::ByteCodeImage Object, can be loaded with
<code>MFactor::ByteCodeImage::deserialize</code>.  This basically exposes all possible internals
about the compiled image.  Used to extract information after compilation, when the
<code>mfactor</code> task has finished.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">3.4</span> Invocation</h3>
<div class="outline-text-3" id="text-3-4">
<p>
If <code>MFACTOR_DEPENDING_OBJECT</code> was set correctly in the host application's Rakefile, then a
rebuild of the application automatically triggers a recompile of the bytecode image.
</p>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24"><span class="section-number-3">3.5</span> <span class="todo TODO">TODO</span> Compilation example</h3>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">3.6</span> Details</h3>
<div class="outline-text-3" id="text-3-6">
</div><div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">3.6.1</span> Fried Quotations(WIP)</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
Fried Quotations (and their basic versions <code>curry</code> and <code>compose</code>) are the equivalent of
closures.  Creating a closure always means allocating space somewhere.  If the closure
creation is inlined, that space can be allocated by the compiler.  Therefore, fried
quotations are currently only supported on the host compiler, and all quotations
containing them are automatically inlined.  Also, if looping code is used to return
multiple results of fried quotation definitions, note that they will be equal to the last
invocation, since no allocation is performed at compile time.  In theory, a runtime check
could be implemented which signals a runtime error when a quotation is being fried more
than once.
</p>

<p>
To describe the transformation, consider the following example:
</p>
<div class="org-src-container">

<pre class="src src-factor"><span style="color: #b22222;">! </span><span style="color: #b22222;">for each i where i runs from 0 below n, x is added to it before applying quot to it</span>
<span style="color: #a020f0;">:</span> <span style="color: #0000ff;">each-int-added</span> <span style="color: #b22222;">( n x quot ( i -- ) -- )</span>
    '[ _ + @ ] each-integer; <span style="color: #b22222;">inline</span>
</pre>
</div>

<p>
Let's define a word that makes use of this word:
</p>
<div class="org-src-container">

<pre class="src src-factor"><span style="color: #b22222;">! </span><span style="color: #b22222;">print values that are passed to the quotation in each-int-added,</span>
<span style="color: #b22222;">! </span><span style="color: #b22222;">the value added to each element is x, it is called 10 times</span>
<span style="color: #a020f0;">:</span> <span style="color: #0000ff;">test</span> <span style="color: #b22222;">( x -- )</span> <span style="color: #008b8b;">10</span> swap [ <span style="color: #008b8b;">.</span> ] each-int-added <span style="color: #a020f0;">;</span>
</pre>
</div>

<p>
Conceptually, the following series of transformations is appplied internally when defining <code>test</code>:
<code>test ( n -- ) 10 swap [ . ] '[ _ + @ ] each-integer</code>
<code>test ( n -- ) 10 swap [ . ] '[ _ + _ call ] each-integer</code>
<code>test ( n -- ) 10 swap [ . ] 0x0002 setmem 0x0001 setmem [ (0x0001) + (0x0002) call ] each-integer</code>
</p>

<p>
The locations sites where the "curried-in" data is used are made explicit, and before the
quotation is passed to <code>each-integer</code>, code is generated that sets the actual memory
locations to their values at runtime.  This is done even when the values are constant and
known at compile time.
</p>

<p>
Since it is effectively rewriting the quotation at
runtime, this incurs a small performance hit.  That also illustrates why these words have
to be inlined.  For every use, the quotation must essentially be copied if the rewritten
items are to not interfere with different invocations.
</p>

<p>
the <code>@</code> specifier actually does no splicing, but simply calls the original quotation.
This must be kept in mind if the spliced quotation is mutable in any way.
</p>

<p>
If code is stored in non-writable memory, another indirection is needed.  The placeholders
are not substituted directly, but filled at runtime by a read to a known writable location:
</p>

<p>
<code>test ( n -- ) 10 swap 0x0001 setmem [ . ] 0x0002 setmem '[ 0x0001 getmem + 0x0002 getmem call ] each-integer</code>
</p>

<p>
This way, no actual code rewrite is performed, but the item use costs another indirection.
Effectively, this allocates "variables" in a data segment, which the compiler assumes to be writable
at runtime.
</p>

<p>
Note that both versions introduce the overhead of copying the code of the original
definition containing the fry at every call site!
</p>

<p>
An obvious optimization here is to separate the last part of the definition, after the
fried quotation, into an own word.  This is very probably almost always the case anyways,
as the example definition above illustrates that typically the quotation is passed to
another combinator.  If that one contains fried quotations, it will obviously further
increase the copied code overhead.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">4</span> VM Implementation</h2>
<div class="outline-text-2" id="text-4">
<p>
The VM is a <a href="http://en.wikipedia.org/wiki/Stack_machine">stack machine</a> with three stacks, a <b>data stack</b> (or parameter stack, pstack),
<b>return stack</b> and a <b>retain stack</b>.
</p>

<p>
The data stack is used for argument passing, while the return stack is used to save the
program counter during sub-routines (and store some debug information).  The retain stack is only
used for putting stack items out of the way temporarily.
</p>

<p>
A program counter points to successively executed primitive instructions.
</p>

<p>
<b>Instruction Set</b>
The Instruction Set for the VM is defined in <a href="instructionset.yml">instructionset.yml</a>.  For a description
of the instructions skip to <a href="#orgtarget4">4.6.3</a>.
</p>

<p>
The following Section describes all definitions that end up in the header file
<a href="src/interpreter.h">src/interpreter.h</a>, the rest describes the implementation in <a href="src/interpreter.c">src/interpreter.c</a>
</p>
</div>

<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34"><span class="section-number-3">4.1</span> Definitions and Datatypes</h3>
<div class="outline-text-3" id="text-4-1">
<p>
In <a href="src/interpreter.h">src/interpreter.h</a> are relevant data type definitions and preprocessor macro
defaults.  These are supposed to be overriden to configure the compiled runtime (see
???).
</p>
</div>

<div id="outline-container-orgheadline29" class="outline-4">
<h4 id="orgheadline29"><span class="section-number-4">4.1.1</span> Typedefs</h4>
<div class="outline-text-4" id="text-4-1-1">
</div><div id="outline-container-orgheadline27" class="outline-5">
<h5 id="orgheadline27"><span class="section-number-5">4.1.1.1</span> Scalar Types</h5>
<div class="outline-text-5" id="text-4-1-1-1">
<p>
The type of actual primitive instructions which are loaded and evaluated, and from which
byte code images are constructed. (see ???)
Size: 1 byte
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #228b22;">inst</span>;
</pre>
</div>

<p>
Targets of normal jumps and calls.  16 bit size, so if an image is bigger than 64K, these
are not sufficient (see ???call instructions)
Size: 2 bytes
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span> <span style="color: #228b22;">short_jump_target</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">relative jumps in 64k on 32 bit </span><span style="color: #b22222;">*/</span>
</pre>
</div>

<p>
Targets of long jumps. Use full 32 Bit address space.  Used for calls to addresses on
stack.
Size: 32 Bit
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">uintptr_t</span> <span style="color: #228b22;">jump_target</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">long absolute jump </span><span style="color: #b22222;">*/</span>
</pre>
</div>

<p>
Type of data actually manipulated on the stack.
Size: 32 Bit
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">uintptr_t</span> <span style="color: #228b22;">cell</span>;                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">memory cell must at least hold pointer </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-5">
<h5 id="orgheadline28"><span class="section-number-5">4.1.1.2</span> Dictionary entries<a id="orgtarget5"></a></h5>
<div class="outline-text-5" id="text-4-1-1-2">
<p>
Type of entries in the dictionary.  These map names to addresses, and hold the flags that
mark a word inline, recursive, or a parsing word.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">dict_entry</span>
{
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">address</span>;           <span style="color: #b22222;">/* </span><span style="color: #b22222;">pointer into memory </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">flags</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">may include other flags later (inline, recursive, etc) </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name_header</span>;      <span style="color: #b22222;">/* </span><span style="color: #b22222;">should always be zero </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name_length</span>;
   <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[];
} <span style="color: #a020f0;">__attribute__</span>((<span style="color: #228b22;">packed</span>)) <span style="color: #228b22;">dict_entry</span>;
</pre>
</div>

<p>
Later, the dictionary entries are collected into the dictionary generated in
<code>bytecode.c</code>.  Note that is not really possible to access entries in that array by index,
since the entries are have the last field as variable-length data on initialization.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-4">
<h4 id="orgheadline30"><span class="section-number-4">4.1.2</span> <a id="orgtarget6"></a>Preprocessor Macros</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
The following all indicate the size of the different components, in <code>cell</code> units.
These are defaults can be changed according to application requirements.
</p>


<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">data memory (affects non-transient data) in cells</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_MEM
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_MEM</span> 256
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">dictionary size (affects number of named items)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_DICT
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_DICT</span> 512
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">parameter stack size (affects transient data)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_PSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_PSTACK</span> 64
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">return stack size (affects nesting of functions)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_RETURNSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_RETURNSTACK</span> 64
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">retain stack size (affects maximum amount of postponing data use) </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_RETAINSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_RETAINSTACK</span> 32
<span style="color: #483d8b;">#endif</span>
</pre>
</div>

<p>
Another macro can be preset or computed: <code>INSTBASE</code>.  This is used to distinguish
primitive instructions from quotations, when executing words on the stack.  Primitives
cannot be interpreted as memory addresses, since these would point into invalid memory.
</p>

<p>
On Cortex-M, all memory addresses higher than 0x80&#x2026; are not accessable, and can be
used for primitive instructions.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> INSTBASE
<span style="color: #483d8b;"> #if</span> (__linux &amp;&amp; __LP64__)
<span style="color: #483d8b;">  #define</span> <span style="color: #a0522d;">INSTBASE</span> 0x80U
<span style="color: #483d8b;"> #elif</span> (CORTEX_M)
<span style="color: #483d8b;">  #define</span> <span style="color: #a0522d;">INSTBASE</span> 0xA0U
<span style="color: #483d8b;"> #else</span>
<span style="color: #483d8b;">  #error</span> <span style="color: #8b2252;">"don't know instruction code base for architecure!"</span>
<span style="color: #483d8b;"> #endif</span>
<span style="color: #483d8b;">#endif</span>
</pre>
</div>

<p>
This influences the opcodes generated in <code>inst_enum.h</code> during building.
</p>

<p>
A <code>cell</code>-sized version for comparison to data values:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INSTBASE_CELL</span> ((<span style="color: #228b22;">cell</span>)INSTBASE&lt;&lt;(8*(<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span> *)-<span style="color: #a020f0;">sizeof</span>(inst))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31"><span class="section-number-4">4.1.3</span> Defines for the generated data in <code>bytecode.c</code></h4>
<div class="outline-text-4" id="text-4-1-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">extern</span> <span style="color: #228b22;">inst</span> <span style="color: #a0522d;">image</span>[];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">dict_entry</span> <span style="color: #a0522d;">dict</span>[VM_DICT];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">uint16_t</span> <span style="color: #a0522d;">dict_hash_index</span>[];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">FF_Table</span>[];
</pre>
</div>

<p>
<code>image</code> holds the actual firmware image, <code>dict</code> is the dictioary, <code>dict_hash_index</code>
creates a hash table for fast lookup of words (see ???). <code>dict</code> is declared with size
because in the lookup function the <code>sizeof()</code> operator is used for bounds-checking.
</p>
</div>
</div>

<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">4.1.4</span> Internal Error Codes</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
These are returned from interpreter() in case of a unrecoverable internal error
(e.g. stack underflow).
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">these values can be returned from interpreter() </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_PSTACK_UFLOW</span> -1
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_PSTACK_OFLOW</span> -2
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RSTACK_UFLOW</span> -3
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RSTACK_OFLOW</span> -4
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RTSTACK_UFLOW</span> -5
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RTSTACK_OFLOW</span> -6
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_INVALID_OPCODE</span> -7
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_MEM_FAULT</span> -8
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_UNKNOWN_FF</span> -9
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_TOKEN_READ</span> -10
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_GENERAL</span> -11
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_UNKNOWN_SPECIAL</span> -12
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">4.1.5</span> Main VM Function Prototype</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
This is the prototype for the function that is supposed to be executed from the
application program.  The only argument is the offset of the first in the bytecode image
to be executed.  The return value indicates the status after a bytecode-program has been
executed.  If it is non-zero, an internal error happened.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">interpreter</span>(<span style="color: #228b22;">short_jump_target</span>);
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">4.2</span> Work Memory</h3>
<div class="outline-text-3" id="text-4-2">
<p>
For allocation of interactively-generated input sequences, such as strings, byte arrays and
quotations, internal memory is reserved.  This is the default target area for the
compilation primitives (TODO: link).
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">main memory to work with </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">memory</span>[VM_MEM];
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline45" class="outline-3">
<h3 id="orgheadline45"><span class="section-number-3">4.3</span> Special Variables</h3>
<div class="outline-text-3" id="text-4-3">
</div><div id="outline-container-orgheadline43" class="outline-4">
<h4 id="orgheadline43"><span class="section-number-4">4.3.1</span> Special Variables Definition</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
The internal state of the interpreter is exposed to the application by predefining an
array of special variables.  These are needed for all instructions that depend on state
that must be influenced by the application.
</p>

<p>
First define an array that holds these Variables:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_NumSpecials</span> 10
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">NumSpecials</span> = _NumSpecials;
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">special_vars</span>[_NumSpecials];
</pre>
</div>

<p>
The list of currently implemented specials:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">currently implemented special variables</span>
<span style="color: #b22222;">0: MP - memory write pointer</span>
<span style="color: #b22222;">1: HANDLER - handler frame location in r(etain) stack (dynamic chain for catch frames)</span>
<span style="color: #b22222;">2: DEBUG_LEVEL - 0 to turn off, increasing will produce more verbose debug output</span>
<span style="color: #b22222;">3: RESTART - word where to restart when hard error occured</span>
<span style="color: #b22222;">4: STEP_HANDLER - address of handler which can be used for single stepping</span>
<span style="color: #b22222;">5: BASE - address of current 64k segment base</span>
<span style="color: #b22222;">6: OUTPUT_STREAM: 1: stdout, 2: stderr, 3: null</span>
<span style="color: #b22222;">*/</span>
</pre>
</div>

<p>
Not all of them are actually in use, the ones that are, are defined as macros so that the
<code>special_vars</code> array needs not be acccessed directly in the following source code:
</p>
</div>

<div id="outline-container-orgheadline36" class="outline-5">
<h5 id="orgheadline36"><span class="section-number-5">4.3.1.1</span> <code>MP</code>: The Memory Write Pointer</h5>
<div class="outline-text-5" id="text-4-3-1-1">
<p>
This holds a pointer to the memory location that is accessed by the compilation primitives
(TOOD: link)
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MP</span> special_vars[0]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-5">
<h5 id="orgheadline37"><span class="section-number-5">4.3.1.2</span> <code>HANDLER</code>: Current Exception handling frame</h5>
<div class="outline-text-5" id="text-4-3-1-2">
<p>
This is used by the application to store information about the current exception handler.
Note that the application does not currently manipulate or access this state, so it is
basically a specialized global variable. TODO: reference the exception handling lib
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDLER</span> special_vars[1]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-5">
<h5 id="orgheadline38"><span class="section-number-5">4.3.1.3</span> <code>DEBUG_LEVEL</code>: VM Debug Verbosity</h5>
<div class="outline-text-5" id="text-4-3-1-3">
<p>
Used to activate debug output for VM internals.  Only used for VM development and debugging.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">DEBUG_LEVEL</span> special_vars[2]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-5">
<h5 id="orgheadline39"><span class="section-number-5">4.3.1.4</span> <code>RESTART</code>: Restart address (deprecated)</h5>
<div class="outline-text-5" id="text-4-3-1-4">
<p>
This used to hold an address that was jumped to in case of internal errors.  This has been
replaced by returning from <code>interpreter()</code> with the internal error code, and the host
application deciding what to do then
</p>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-5">
<h5 id="orgheadline40"><span class="section-number-5">4.3.1.5</span> <code>STEP_HANDLER</code>: Single Stepping Handler (not in use)</h5>
<div class="outline-text-5" id="text-4-3-1-5">
<p>
This shall hold an address which is called on every step of the currently executed bytecode
image.  Meant for implementing single step debugging, where the actual handler would be
written as mfactor source.
</p>
</div>
</div>

<div id="outline-container-orgheadline41" class="outline-5">
<h5 id="orgheadline41"><span class="section-number-5">4.3.1.6</span> <code>BASE</code>: Current Segment base address</h5>
<div class="outline-text-5" id="text-4-3-1-6">
<p>
This hold the address that is added to <b>all</b> internal calls (TODO: link to relevant call
primitives).  Usually it holds the address of the <code>image</code>-variable, that is generated in
<code>generated/bytecode.c</code>.  This allows the image to be relocatable, so that the actuall call
target (16 bit value) is computed by adding it to the value of <code>BASE</code>.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BASE</span> special_vars[5]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline42" class="outline-5">
<h5 id="orgheadline42"><span class="section-number-5">4.3.1.7</span> <code>OUTPUT_STREAM</code>: Output Stream descriptor</h5>
<div class="outline-text-5" id="text-4-3-1-7">
<p>
The value of this variable is used everytime something should be output.  It determines
which <code>File</code> pointer is passed to the standard c output functions in <code>current_fd()</code> (see
<a href="#orgtarget7">4.4.1</a>)
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">OUTPUT_STREAM</span> special_vars[6]
</pre>
</div>

<p>
The possible values are defined as:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">known stream descriptors for OUTPUT_STREAM </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STDOUT</span> 1
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STDERR</span> 2
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NULLOUT</span> 3
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline44" class="outline-4">
<h4 id="orgheadline44"><span class="section-number-4">4.3.2</span> <a id="orgtarget8"></a>Special Variables Initialization</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
This helper is called at the beginning of <code>interpreter()</code> to initialize some special
variables to values then known.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">init_specials</span>() {
   HANDLER = 0;
   MP = (<span style="color: #228b22;">cell</span>)memory; <span style="color: #b22222;">/* </span><span style="color: #b22222;">start of user memory </span><span style="color: #b22222;">*/</span>
   BASE = (<span style="color: #228b22;">cell</span>)&amp;image; <span style="color: #b22222;">/* </span><span style="color: #b22222;">start of bytecode segment </span><span style="color: #b22222;">*/</span>
   OUTPUT_STREAM = STDOUT; <span style="color: #b22222;">/* </span><span style="color: #b22222;">output to standard output per default </span><span style="color: #b22222;">*/</span>
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline51" class="outline-3">
<h3 id="orgheadline51"><span class="section-number-3">4.4</span> Helper Funtions</h3>
<div class="outline-text-3" id="text-4-4">
</div><div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46"><span class="section-number-4">4.4.1</span> Output Handling<a id="orgtarget7"></a></h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
One file-local variable that holds the current Output stream for io operations:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">static</span> <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">Ostream</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">used by reporting functions, so they can temporarily</span>
<span style="color: #b22222;">                          print to different file descriptor </span><span style="color: #b22222;">*/</span>


<span style="color: #b22222;">/* </span><span style="color: #b22222;">get the current stdio FILE from the special variable, or NULL if unknown or muted by</span>
<span style="color: #b22222;"> * choosing NULLOUT </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">FILE</span> * <span style="color: #0000ff;">current_fd</span>(<span style="color: #228b22;">void</span>)
{
        <span style="color: #a020f0;">if</span> (OUTPUT_STREAM == 2)
                <span style="color: #a020f0;">return</span> stderr;
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (OUTPUT_STREAM == 1)
                <span style="color: #a020f0;">return</span> stdout;
        <span style="color: #a020f0;">else</span>
                <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47"><span class="section-number-4">4.4.2</span> Return Stack Entry Format</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
The return stack, which holds the links of the dynamic chain, has entries in the following
format:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">return_entry</span> {
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">return_address</span>;
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">current_call</span>;
} <span style="color: #228b22;">return_entry</span>;
</pre>
</div>

<p>
Technically, for execution, only the <code>return_address</code> portion is interesting.  But for
debugging purposes and backtraces it is useful to record the starting address of the
current quotation.  This is done with the <code>current_call</code> field.
</p>
</div>
</div>

<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">4.4.3</span> Word Lookup: Dictionary support</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
There is built-in support for work lookup in the dictionary (see TODO: link to dictionary
explanation), mainly for speed reasons.  During compilation, a simple hash table was
created by the ruby translator (TODO: link).  This code is the runtime access portion.  It
uses a very simple hash function to look up a starting index that can be used for looking
up a word with a linear search from there.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #228b22;">uint32_t</span> <span style="color: #0000ff;">lookup_ht_entry</span>(<span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">length</span>, <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">name</span>) {
   <span style="color: #228b22;">uint32_t</span> <span style="color: #a0522d;">hash</span> = 5381;
   <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; length; i++) {
      hash = hash * 33 + name[i];
   }
   <span style="color: #a020f0;">return</span> (<span style="color: #228b22;">cell</span>)dict+dict_hash_index[hash%256];
}
</pre>
</div>

<p>
For debugging, there is a (slow) reverse lookup, that gets the word name from its
execution address:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">get the name of the word, only for debugging </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">probably fails for non-null-terminated strings </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">char</span>* <span style="color: #0000ff;">find_by_address</span>( <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">word</span>)
{
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">notfound</span>[] = <span style="color: #8b2252;">"(internal or private)"</span>;
   <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">char</span> * <span style="color: #a0522d;">ptr</span>=(<span style="color: #228b22;">char</span>*)dict;
        (ptr &lt; ((<span style="color: #228b22;">char</span>*)dict+<span style="color: #a020f0;">sizeof</span>(dict)))&amp;&amp;(((<span style="color: #228b22;">dict_entry</span>*)ptr)-&gt;name_length &gt; 0);
        ptr += (((<span style="color: #228b22;">dict_entry</span>*)ptr)-&gt;name_length + 3*<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>) + <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">void</span>*))) {
      <span style="color: #228b22;">dict_entry</span> *<span style="color: #a0522d;">dptr</span> = (<span style="color: #228b22;">dict_entry</span>*)ptr;
      <span style="color: #a020f0;">if</span> (dptr-&gt;address == word)
         <span style="color: #a020f0;">return</span> dptr-&gt;name;
   }
   <span style="color: #a020f0;">return</span> notfound;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49"><span class="section-number-4">4.4.4</span> Parsing Numbers</h4>
<div class="outline-text-4" id="text-4-4-4">
<p>
Whenever a piece of input is unknown, it is tried to parse as a number before giving up.
This uses libc's <code>sscanf()</code>, and is exposed via the <code>parsenum</code> primitive, which uses this
function.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">static</span> <span style="color: #228b22;">bool</span> <span style="color: #0000ff;">parse_number</span>(<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span>, <span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">number</span>){
   <span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span>;
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">read</span> = sscanf(str,<span style="color: #8b2252;">"%i"</span>,&amp;num);
   <span style="color: #a020f0;">if</span> (read == 1) {
      *number = (<span style="color: #228b22;">cell</span>)num;
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
   } <span style="color: #a020f0;">else</span> {
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
   }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-4">
<h4 id="orgheadline50"><span class="section-number-4">4.4.5</span> Debug output</h4>
<div class="outline-text-4" id="text-4-4-5">
<p>
For the <code>st</code> primitive and in case of errors, the stack contents are sometimes printed to
<code>stderr</code>.  This is done with the following file-local functions:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">display data stack entries </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">printstack</span>(<span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">stack</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"stack:"</span>);
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">ptr</span> = stack;ptr &lt; sp;ptr++)
   {
      fprintf(Ostream, <span style="color: #8b2252;">" %#lx"</span>,*ptr);
   }
   fprintf(Ostream, <span style="color: #8b2252;">"\n"</span>);
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">display return stack entries </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_return_stack</span>(<span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">base</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"stack:"</span>);
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">ptr</span> = sp-1;ptr &gt;= stack;ptr--)
   {
      fprintf(Ostream, <span style="color: #8b2252;">" {%#lx-&gt;%#lx}"</span>,((<span style="color: #228b22;">uintptr_t</span>)ptr-&gt;current_call-(<span style="color: #228b22;">uintptr_t</span>)base),
              ((<span style="color: #228b22;">uintptr_t</span>)ptr-&gt;return_address)-(<span style="color: #228b22;">uintptr_t</span>) base);
   }
   fprintf(Ostream, <span style="color: #8b2252;">"\n"</span>);
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">print a backtrace of the return stack </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">backtrace</span>(<span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">base</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">pc</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"backtrace @ %#lx:\n"</span>,(<span style="color: #228b22;">uintptr_t</span>)(pc-base));
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">ptr</span> = sp-1;ptr &gt;= stack;ptr--)
   {
      <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">current_name</span> = find_by_address(ptr-&gt;current_call);
      fprintf(Ostream, <span style="color: #8b2252;">"%#lx %s\n"</span>,(<span style="color: #228b22;">uintptr_t</span>)(ptr-&gt;current_call - base),current_name);
   }
}
</pre>
</div>

<p>
Helper for printing errors:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_error</span>(<span style="color: #228b22;">char</span> * <span style="color: #a0522d;">str</span>)
{
   fprintf(stderr, <span style="color: #8b2252;">"error: "</span>);
   fprintf(stderr, str);
   fprintf(stderr, <span style="color: #8b2252;">"\n"</span>);
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline59" class="outline-3">
<h3 id="orgheadline59"><span class="section-number-3">4.5</span> Used Subroutines (defined as Macros)</h3>
<div class="outline-text-3" id="text-4-5">
<p>
There are several subroutines that are repeatedly used in <code>interpreter()</code>, which operate
on the static data that is only defined there.  Because of that, they are implemented as
preprocessor macros.
</p>
</div>
<div id="outline-container-orgheadline52" class="outline-4">
<h4 id="orgheadline52"><span class="section-number-4">4.5.1</span> Backtrace printing</h4>
<div class="outline-text-4" id="text-4-5-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">BACKTRACE</span>() <span style="color: #a020f0;">do</span> {                                 \
      <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">old_out</span> = Ostream;                          \
      Ostream = stderr;                                  \
      printstack(psp,pstack);                            \
      printstack(retainsp,retainstack);                  \
      backtrace(returnsp,returnstack,(<span style="color: #228b22;">inst</span> *)BASE,pc);   \
      Ostream = old_out;                                 \
   }       <span style="color: #a020f0;">while</span> (0)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">4.5.2</span> Errors during primitive execution</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
Whenever something unrecoverable handles, this is called.  Currently just returns the
error code from <code>interpreter()</code>.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">handle_error</span>(<span style="color: #a0522d;">code</span>) <span style="color: #a020f0;">do</span> {<span style="color: #a020f0;">return</span> code;} <span style="color: #a020f0;">while</span>(0)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline54" class="outline-4">
<h4 id="orgheadline54"><span class="section-number-4">4.5.3</span> Stack Operation Assertion</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
These macros are used when popping and pushing elements on stacks, and check if the stack
is empty or full.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">assert_pop</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">min</span>,<span style="color: #a0522d;">name</span>,<span style="color: #a0522d;">fail_reason</span>) <span style="color: #a020f0;">if</span> (sp &lt;= min) { print_error(name <span style="color: #8b2252;">"stack underflow"</span>);BACKTRACE();handle_error(fail_reason);}
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">assert_push</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">min</span>,<span style="color: #a0522d;">size</span>,<span style="color: #a0522d;">fail_reason</span>) <span style="color: #a020f0;">if</span> (sp &gt; min+size){ print_error(<span style="color: #8b2252;">"stack overflow"</span>);BACKTRACE();handle_error(fail_reason);}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline58" class="outline-4">
<h4 id="orgheadline58"><span class="section-number-4">4.5.4</span> Stack operations</h4>
<div class="outline-text-4" id="text-4-5-4">
<p>
These macros are the basic internal stack manupulation functions.  All stacks are assumed
empty ascending.  The following routines are general:
</p>

<p>
Peeking into the stack (as opposed to removing a value), currently only used for the
<code>_dup</code> primitive
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">peek_n</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">nth</span>) (*(sp-nth))
</pre>
</div>

<p>
Basic push and pop operations.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">push value onto stack indicated by stack pointer sp </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">push_</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">val</span>) *sp=val;sp++;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">pop value from stack indicated by stack pointer sp </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">pop_</span>(<span style="color: #a0522d;">sp</span>) --sp;*sp;
</pre>
</div>

<p>
The rest is meant for the three specific stacks (TODO: link to stack explanation).  The
push functions push (safely) a value onto the respective stack.  The pop functions pop (safely) a
value from the respective stack.
</p>
</div>
<div id="outline-container-orgheadline55" class="outline-5">
<h5 id="orgheadline55"><span class="section-number-5">4.5.4.1</span> Data Stack (Parameter Stack)</h5>
<div class="outline-text-5" id="text-4-5-4-1">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ppush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(psp,pstack,VM_PSTACK,INTERNAL_ERROR_PSTACK_OFLOW);push_(psp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ppop</span>() ({assert_pop(psp,pstack,<span style="color: #8b2252;">"p"</span>,INTERNAL_ERROR_PSTACK_UFLOW);pop_(psp)})
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline56" class="outline-5">
<h5 id="orgheadline56"><span class="section-number-5">4.5.4.2</span> Return Stack</h5>
<div class="outline-text-5" id="text-4-5-4-2">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">returnpush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(returnsp,returnstack,VM_RETURNSTACK,INTERNAL_ERROR_RSTACK_OFLOW);push_(returnsp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">returnpop</span>() ({assert_pop(returnsp,returnstack,<span style="color: #8b2252;">"return"</span>,INTERNAL_ERROR_RSTACK_UFLOW);pop_(returnsp)})
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-5">
<h5 id="orgheadline57"><span class="section-number-5">4.5.4.3</span> Retain Stack</h5>
<div class="outline-text-5" id="text-4-5-4-3">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">retainpush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(retainsp,retainstack,VM_RETAINSTACK,INTERNAL_ERROR_RTSTACK_OFLOW);push_(retainsp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">retainpop</span>() ({assert_pop(retainsp,retainstack,<span style="color: #8b2252;">"retain"</span>,INTERNAL_ERROR_RTSTACK_OFLOW);pop_(retainsp)})
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline82" class="outline-3">
<h3 id="orgheadline82"><span class="section-number-3">4.6</span> Main Interpreter function <code>interpreter()</code></h3>
<div class="outline-text-3" id="text-4-6">
<p>
Basic Flowchart
</p>

<div class="figure">
<p><object type="image/svg+xml" data="img/interpreter_flow.svg" >
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
The <code>interpreter()</code> functions is structured as follows:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #0000ff;">interpreter</span>(<span style="color: #228b22;">short_jump_target</span> <span style="color: #a0522d;">start_address</span>) {

   &lt;&lt;state_definition&gt;&gt;

   &lt;&lt;state_initialization&gt;&gt;

   <span style="color: #a020f0;">while</span>(1) {
      <span style="color: #228b22;">inst</span> <span style="color: #a0522d;">i</span>;
      i = (*pc++);
   <span style="color: #008b8b;">dispatch</span>:
      &lt;&lt;debug_statements&gt;&gt;
      <span style="color: #a020f0;">switch</span>(i) {
         &lt;&lt;big_fat_switch&gt;&gt;
         <span style="color: #a020f0;">default</span>:
            printf(<span style="color: #8b2252;">"unimplemented instruction %#x\n"</span>,i);
            handle_error(INTERNAL_ERROR_INVALID_OPCODE);
      }
   <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">normal instructions skip the call execution paths </span><span style="color: #b22222;">*/</span>
   <span style="color: #008b8b;">nested_call</span>:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">common execution path for non-tail calls </span><span style="color: #b22222;">*/</span>
      &lt;&lt;nested_call_common&gt;&gt;
   tail_call:    <span style="color: #b22222;">/* </span><span style="color: #b22222;">common execution path for tail calls </span><span style="color: #b22222;">*/</span>
      &lt;&lt;tail_call_common&gt;&gt;
   end_inst:     <span style="color: #b22222;">/* </span><span style="color: #b22222;">end of instruction processing </span><span style="color: #b22222;">*/</span>
      (<span style="color: #228b22;">void</span>) 0;
   }
}
</pre>
</div>

<p>
The labels after the switch statement are common excution paths of several primitives.
</p>
</div>

<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">4.6.1</span> Internal State Definition</h4>
<div class="outline-text-4" id="text-4-6-1">
</div>

<div id="outline-container-orgheadline60" class="outline-5">
<h5 id="orgheadline60"><span class="section-number-5">4.6.1.1</span> Stacks</h5>
<div class="outline-text-5" id="text-4-6-1-1">
<ul class="org-ul">
<li>data stack (or parameter stack) and pointer</li>
<li>return stack and pointer</li>
<li>retain stack and pointer</li>
</ul>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">parameter stack </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">pstack</span>[VM_PSTACK]={0};
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">psp</span>;
psp = &amp;pstack[0];
<span style="color: #b22222;">/* </span><span style="color: #b22222;">return stack </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">returnstack</span>[VM_RETURNSTACK]={{0}};
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">returnsp</span>;
returnsp = &amp;returnstack[0];
<span style="color: #b22222;">/* </span><span style="color: #b22222;">retain stack </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">retainstack</span>[VM_RETAINSTACK]={0};
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">retainsp</span>;
retainsp = &amp;retainstack[0];
</pre>
</div>

<p>
The data and retain stacks are using scalar elements of type <code>cell</code>, while the return
stack holds structs.
</p>

<p>
The size macros are defined in the header file (see <a href="#orgtarget6">4.1.2</a>), and control the
memory usage of the VM.
</p>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-5">
<h5 id="orgheadline61"><span class="section-number-5">4.6.1.2</span> Program counter</h5>
<div class="outline-text-5" id="text-4-6-1-2">
<p>
This is the most basic state for any program interpreting machine.  It holds the address
of the next primitive instruction in the instruction stream (bytecode image).
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">pc</span>;
pc = &amp;image[(start_address ? : START_WORD_OFFSET)];  <span style="color: #b22222;">/* </span><span style="color: #b22222;">point to the start of the program </span><span style="color: #b22222;">*/</span>
</pre>
</div>

<p>
The initial value is either taken from the <code>interpreter()</code> call as parameter, or by using
the <code>START_WORD_OFFSET</code> macro from <code>bytecode.h</code>, that translates the <code>START_WORD</code> global
variable (see <a href="#orgtarget2">1.3</a>) into an address.
</p>
</div>
</div>

<div id="outline-container-orgheadline62" class="outline-5">
<h5 id="orgheadline62"><span class="section-number-5">4.6.1.3</span> Tail Call Optimization<a id="orgtarget9"></a></h5>
<div class="outline-text-5" id="text-4-6-1-3">
<p>
The MFactor implementation relies on (explicit) <a href="https://en.wikipedia.org/wiki/Tail_call">tail call elimination</a>.  Because of the
nature of the language, the compiler can detect all cases of tail calls easily and
replaces the <code>call</code> instructions with their <code>tcall</code> equivalents:
</p>
<ul class="org-ul">
<li><code>bcall</code> -&gt; <code>btcall</code></li>
<li><code>scall</code> -&gt; <code>stcall</code></li>
<li><code>acall</code> -&gt; <code>atcall</code></li>
</ul>

<p>
The <code>tcall</code> instructions all amount to a jump to the called word, thus replacing the
current stack frame instead of adding one to the dynamic chain.  Since Iteration is
implemented with (tail)-recursion, disabling tail calls severly limit loop execution, and
should only be turned on locally for debugging purposes.
This variable controls wether tail calls should be handled as such, or redirected to
nested calls:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">static</span> <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">tailcall</span>;
tailcall = <span style="color: #008b8b;">true</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">enable tail call jumping by default </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline63" class="outline-5">
<h5 id="orgheadline63"><span class="section-number-5">4.6.1.4</span> Helper "Register"</h5>
<div class="outline-text-5" id="text-4-6-1-4">
<p>
To help manage jumping through the code, a variable <code>x</code> is defined here and used in
various primitive instructions.  Normally, the needed variables are defined locally in the
intruction cases.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #228b22;">cell</span> <span style="color: #a0522d;">x</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">temporary value for operations </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline64" class="outline-5">
<h5 id="orgheadline64"><span class="section-number-5">4.6.1.5</span> Debug Mode</h5>
<div class="outline-text-5" id="text-4-6-1-5">
<p>
To debug internals, this <code>debug_mode</code> state can be set (also via an isntruction, TODO:
link).  If so, it outputs internal state before processing an instruction, and waits for a
keypress before processing it.  The <code>debug_nest</code> counter is used to keep track of return
stack levels to make sure debug mode is exited corretly and to provide nesting
information.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #b22222;">/* </span><span style="color: #b22222;">single step debugging</span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">debug_nest</span> = 0; <span style="color: #b22222;">/* </span><span style="color: #b22222;">used in debug mode to track when</span>
<span style="color: #b22222;">                              * to stop single stepping</span><span style="color: #b22222;">*/</span>
<span style="color: #228b22;">bool</span> <span style="color: #a0522d;">debug_mode</span> = <span style="color: #008b8b;">false</span>;
<span style="color: #483d8b;">#if</span> DEBUG
debug_mode=<span style="color: #008b8b;">true</span>;
<span style="color: #483d8b;">#endif</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68"><span class="section-number-4">4.6.2</span> State initialization</h4>
<div class="outline-text-4" id="text-4-6-2">
<p>
The initial of the vm: Program counter points to the starting word, data and retain stack
empty, return stack contains a default frame.
</p>
</div>
<div id="outline-container-orgheadline66" class="outline-5">
<h5 id="orgheadline66"><span class="section-number-5">4.6.2.1</span> Output File Descriptor</h5>
<div class="outline-text-5" id="text-4-6-2-1">
<p>
The value passed to all libc stdio commands used during primitive instruction execution.
</p>
<div class="org-src-container">

<pre class="src src-C">Ostream = stdout;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">print everything to stdout per default </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-5">
<h5 id="orgheadline67"><span class="section-number-5">4.6.2.2</span> Special Variable Initalization</h5>
<div class="outline-text-5" id="text-4-6-2-2">
<p>
See <a href="#orgtarget8">4.3.2</a>.
</p>
<div class="org-src-container">

<pre class="src src-C">init_specials();
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">4.6.3</span> Primitive Instructions<a id="orgtarget4"></a></h4>
<div class="outline-text-4" id="text-4-6-3">
<p>
All the primitives, that defined words consist of, are described here.  Some of them are
prepended with underscores to avoid name clashes with existing c functionality.
</p>
</div>

<div id="outline-container-orgheadline69" class="outline-5">
<h5 id="orgheadline69"><span class="section-number-5">4.6.3.1</span> Basic stack manipulation</h5>
<div class="outline-text-5" id="text-4-6-3-1">
<dl class="org-dl">
<dt><code>drop</code></dt><dd>remove value on top of data stack</dd>
<dt><code>dup</code></dt><dd>(internally named _dup to avoid name conflits) duplicate the item on top of
data stack</dd>
<dt><code>swap</code></dt><dd>swap two top values on data stack</dd>
<dt><code>to_r</code></dt><dd>move top of data stack to retain stack</dd>
<dt><code>r_from</code></dt><dd>move top of retain stack to data stack</dd>
<dt><code>clear</code></dt><dd>clear contents of data stack</dd>
</dl>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> drop: ppop(); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> _dup: ppush(peek_n(psp,1)); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> swap: {
   x=ppop();
   <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">y</span> = ppop();
   ppush(x);
   ppush(y);
} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> to_r: retainpush(ppop()); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> r_from: ppush(retainpop()); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> clear: psp = &amp;pstack[0]; <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline70" class="outline-5">
<h5 id="orgheadline70"><span class="section-number-5">4.6.3.2</span> Arithmetic Instructions</h5>
<div class="outline-text-5" id="text-4-6-3-2">
<p>
All arithmetic instructions either manipulate the value on top of the stack, or replace
the two top values with the results.  For defining unary and binary operations with C
operators, two helper macros are used:
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">UNOP</span>(<span style="color: #a0522d;">op</span>) {                              \
      x=(op ((<span style="color: #228b22;">intptr_t</span>) ppop()));               \
      ppush(x);                                 \
   } <span style="color: #a020f0;">break</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">BINOP</span>(<span style="color: #a0522d;">op</span>) {                                                     \
      x = ppop();                                                       \
      <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">y</span> = ppop();                                                  \
      ppush(((<span style="color: #228b22;">intptr_t</span>)y) op ((<span style="color: #228b22;">intptr_t</span>)x));                            \
   } <span style="color: #a020f0;">break</span>
</pre>
</div>

<p>
The instructions themselves:
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> add: BINOP(+); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> mul: <span style="color: #228b22;">BINOP</span>(*); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> sub: BINOP(-); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> neg: UNOP(-); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> asl: BINOP(&lt;&lt;); <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">arithmetic shift left </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">case</span> asr: BINOP(&gt;&gt;); <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">arithmetic shift right </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">case</span> div: BINOP(/); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> mod: BINOP(%); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> bitand: BINOP(&amp;); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> bitor: BINOP(|); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> bitxor: BINOP(^); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> bitnot: UNOP(~); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> gt: BINOP(&gt;); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> lt: BINOP(&lt;); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> eql: BINOP(==); <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline71" class="outline-5">
<h5 id="orgheadline71"><span class="section-number-5">4.6.3.3</span> Constants</h5>
<div class="outline-text-5" id="text-4-6-3-3">
<p>
These push constants onto the stack.  These save space compared to pushing a literal onto
the stack, which takes two bytes instead of one.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> zero: ppush(0); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> one: ppush(1); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> two: ppush(2); <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline72" class="outline-5">
<h5 id="orgheadline72"><span class="section-number-5">4.6.3.4</span> Access to Internal Constants</h5>
<div class="outline-text-5" id="text-4-6-3-4">
<p>
These provide information about some internals to the application:
</p>
<ul class="org-ul">
<li>work memory bounds</li>
<li>dictionary bounds</li>
<li>size in bytes of stack elements (platform-dependent)</li>
<li>starting instruction code</li>
</ul>

<p>
Note that the memrange and memstart/memend instructions are redundant (TODO: remove memrange)
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> memstart: ppush((<span style="color: #228b22;">cell</span>)memory); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> memend: ppush((<span style="color: #228b22;">cell</span>)(memory+VM_MEM)); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> memrange:
   ppush((<span style="color: #228b22;">cell</span>) memory);
   ppush((<span style="color: #228b22;">cell</span>) memory+VM_MEM*<span style="color: #a020f0;">sizeof</span>(cell));
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> dictstart: ppush((<span style="color: #228b22;">cell</span>)dict); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> dictend: ppush((<span style="color: #228b22;">cell</span>)(dict+VM_DICT)); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> cellsize: ppush((<span style="color: #228b22;">cell</span>)<span style="color: #a020f0;">sizeof</span>(cell)); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> instbase: ppush((<span style="color: #228b22;">cell</span>)INSTBASE); <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline73" class="outline-5">
<h5 id="orgheadline73"><span class="section-number-5">4.6.3.5</span> Access to Internal State</h5>
<div class="outline-text-5" id="text-4-6-3-5">
<p>
These primitives expose internal state to the application.
</p>

<p>
Access to the stack pointers is needed for saving and storing state, and is mainly
provided to be able to implement exception handling, which needs to store the values of
these pointers(on the retain stack) for later recovery.
</p>

<p>
The number of the desired stack pointer is taken from top of stack.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> get_sp:
   <span style="color: #a020f0;">switch</span> (ppop()) {
      <span style="color: #a020f0;">case</span> 0 : ppush((<span style="color: #228b22;">cell</span>)psp); <span style="color: #a020f0;">break</span>;
      <span style="color: #a020f0;">case</span> 1 : ppush((<span style="color: #228b22;">cell</span>)retainsp); <span style="color: #a020f0;">break</span>;
      <span style="color: #a020f0;">case</span> 2 : ppush((<span style="color: #228b22;">cell</span>)returnsp); <span style="color: #a020f0;">break</span>;
      <span style="color: #a020f0;">default</span>: ppush((<span style="color: #228b22;">cell</span>)0); <span style="color: #a020f0;">break</span>;
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> set_sp:
   {
      <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">n</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
      <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">newsp</span> = (<span style="color: #228b22;">cell</span>*)ppop();
      <span style="color: #a020f0;">switch</span> (n) {
         <span style="color: #a020f0;">case</span> 0 : psp = newsp; <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> 1 : retainsp = newsp; <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> 2 : returnsp = (<span style="color: #228b22;">return_entry</span> *)newsp; <span style="color: #a020f0;">break</span>;
      }
   } <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
Access to the special variables is provided to control or query several aspects of
interpreter state, see <a href="#orgheadline45">4.3</a> for details.  Number of special variable is taken
from top of stack.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> get_special:
   {
      <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">i</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
      <span style="color: #a020f0;">if</span> (i &lt; NumSpecials)
         ppush(special_vars[i]);
      <span style="color: #a020f0;">else</span> {
         printf(<span style="color: #8b2252;">"illegal specials index: %d\n"</span>, i);
         handle_error(INTERNAL_ERROR_UNKNOWN_SPECIAL);
      }
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> set_special:
   {
      <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">i</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
      <span style="color: #a020f0;">if</span> (i &lt; NumSpecials)
         special_vars[i] = ppop();
      <span style="color: #a020f0;">else</span> {
         printf(<span style="color: #8b2252;">"illegal specials index: %d\n"</span>, i);
         handle_error(INTERNAL_ERROR_UNKNOWN_SPECIAL);
      }
   } <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
Push the current stack level on tos
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> stack_level: ppush(psp-pstack); <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline74" class="outline-5">
<h5 id="orgheadline74"><span class="section-number-5">4.6.3.6</span> Literal Instructions<a id="orgtarget1"></a></h5>
<div class="outline-text-5" id="text-4-6-3-6">
<p>
Literal instructions all push a value that is defined immediately after the instruction in
the instruction stream, and push it onto the data stack. If the current program counter
points to this:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">litb</td>
<td class="org-right">0x04</td>
<td class="org-left">inst<sub>1</sub></td>
<td class="org-left">inst<sub>2</sub></td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
<p>
it will point to this after execution:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">inst<sub>1</sub></td>
<td class="org-left">inst<sub>2</sub></td>
<td class="org-left">&#x2026;</td>
</tr>
</tbody>
</table>
<p>
Because the literal byte is a "argument" to the litb instruction.
The different literal instructions ahve different width arguments.
</p>
<ul class="org-ul">
<li><code>litb</code> pushes a byte-sized number</li>
<li><code>liti</code> pushes a cell-sized number</li>
</ul>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> litb:              <span style="color: #b22222;">/* </span><span style="color: #b22222;">byte literal </span><span style="color: #b22222;">*/</span>
  x=(cell)(*(pc++));
  ppush(x);
  <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ref:
<span style="color: #a020f0;">case</span> liti:               <span style="color: #b22222;">/* </span><span style="color: #b22222;">cell-wide literal </span><span style="color: #b22222;">*/</span>
  x=*((<span style="color: #228b22;">cell</span> *)pc);
  ppush(x);
  pc+=<span style="color: #a020f0;">sizeof</span>(cell);
  <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
<code>litc</code> is meant for complex (non-scalar) literals like sequences.  It expects its
argument to be in the format described in <a href="src/seq_headers.h">src/seq_headers.h</a>.  The only really
important thing about that format here is that the second byte specifies the length.
After execution of <code>litc</code>, the address of that length-defining byte is left on the stack,
and the pc is adjustet to correctly skip all the inline data.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> litc: {              <span style="color: #b22222;">/* </span><span style="color: #b22222;">complex inline literal </span><span style="color: #b22222;">*/</span>
  <span style="color: #b22222;">/* </span><span style="color: #b22222;">pc is already at the next item -&gt; header byte </span><span style="color: #b22222;">*/</span>
  <span style="color: #228b22;">seq_header</span> <span style="color: #a0522d;">h</span> = (<span style="color: #228b22;">seq_header</span>)(*pc);
  ppush((<span style="color: #228b22;">cell</span>)pc+1);    <span style="color: #b22222;">/* </span><span style="color: #b22222;">leave address of count byte on stack </span><span style="color: #b22222;">*/</span>
  pc += 2 + fe_seq_size(h,pc+1);
  } <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
<code>oplit</code> is like <code>litb</code>, and is intended for pushing an instruction on the stack literally,
instead of executing it.  It is needed by the interactive bytecode-compiler to put
instructions onto the stack.  It does however an additional transformation:  since
primitives on the stack are no different from addresses in regard to being <code>call</code>'ed,
the way to distinguish between a primitive to execute and an address to jump to is, that
primitives are represented as addresses that would be invalid otherwise.  That is also the
reason for different values of <code>INSTBASE</code> (see <a href="#orgtarget6">4.1.2</a>).
</p>

<p>
In essence:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">oplit</td>
<td class="org-right">0xa4</td>
</tr>
</tbody>
</table>
<p>
pushes <code>0xa4000000</code> onto the stack.  Since this would be an invalid memory address on the
chosen architecture (checked during <code>scall</code> and <code>stcall</code> in <a href="#orgtarget10">4.6.3.8</a>), it
is later known to be a primitive, not the location of a quotation when called.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> oplit:             <span style="color: #b22222;">/* </span><span style="color: #b22222;">literal primitive operation </span><span style="color: #b22222;">*/</span>
   x=(cell)*(pc++);
   ppush(x&lt;&lt;(8*(<span style="color: #a020f0;">sizeof</span>(cell)-<span style="color: #a020f0;">sizeof</span>(inst))));
   <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
<code>qstart</code> is pushing a literal quotation on the stack.  Since all quotations are static
code, they are uniquely idenfified by that address.  This address can then later be used
by a call instruction, namely <code>scall</code> or <code>stcall</code>.  The implementation is not much
different from <code>litc</code>, but quotations don't have a sequence header, only a count byte as
first element.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> qstart: {
   <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">l</span> = *((<span style="color: #228b22;">uint8_t</span> *)pc) + 1;
   ppush((cell)(pc + 1));
   <span style="color: #b22222;">/* </span><span style="color: #b22222;">skip over quotation length and count byte, leaving pc after qend </span><span style="color: #b22222;">*/</span>
   pc = pc + l + 1;
} <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline75" class="outline-5">
<h5 id="orgheadline75"><span class="section-number-5">4.6.3.7</span> IO Primitives</h5>
<div class="outline-text-5" id="text-4-6-3-7">
<p>
Several primitives make calls to libc's stdio functionality.  All output is directed to
<code>Ostream</code> (see [[output-handling]).
</p>
<dl class="org-dl">
<dt><code>emit</code></dt><dd>output top of stack as <code>char</code></dd>
<dt><code>receive</code></dt><dd>read(blocking) one character from stdin</dd>
<dt><code>pwrite</code></dt><dd>"pretty-write", outputs top of stack with printf as decimal</dd>
<dt><code>pwritex</code></dt><dd>"pretty-write-hex", outputs top of stack with printf as hex and <code>0x</code> prefix</dd>
<dt><code>writex</code></dt><dd>"write-hex", outputs top of stack with printf as hex</dd>
</dl>

<p>
The output functions all check <code>current_fd()</code> (see <a href="#orgtarget7">4.4.1</a>).  If it is NULL, the
element not to be output at all and simply dropped.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> emit:
   <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>) {
      fputc(ppop(),current_fd());
      fflush(stdout);                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">TODO remove when flushing is delegated to</span>
<span style="color: #b22222;">                                       * higher level calls </span><span style="color: #b22222;">*/</span>
   } <span style="color: #a020f0;">else</span>
      (<span style="color: #228b22;">void</span>) ppop();
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> receive:
   ppush(read_char()); <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> _pwrite:
   <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
      fprintf(current_fd(), <span style="color: #8b2252;">"%ld"</span>, ppop());
   <span style="color: #a020f0;">else</span>
      (<span style="color: #228b22;">void</span>) ppop();
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> pwritex:
   <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
      fprintf(current_fd(), <span style="color: #8b2252;">"%#lx"</span>, ppop());
   <span style="color: #a020f0;">else</span>
      (<span style="color: #228b22;">void</span>) ppop();
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> writex:
   <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
      fprintf(current_fd(), <span style="color: #8b2252;">"%lx"</span>, ppop());
   <span style="color: #a020f0;">else</span>
      (<span style="color: #228b22;">void</span>) ppop();
   <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline76" class="outline-5">
<h5 id="orgheadline76"><span class="section-number-5">4.6.3.8</span> Call/Return Instructions<a id="orgtarget10"></a></h5>
<div class="outline-text-5" id="text-4-6-3-8">
<p>
These instructions implement control flow, and make use of the return stack.  The
difference between the call instructions is how they get their target address, how wide
that address is and wether or not they execute a jump (<a href="#orgtarget9">4.6.1.3</a>).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">primitive</th>
<th scope="col" class="org-left">where to get address</th>
<th scope="col" class="org-left">type of address</th>
<th scope="col" class="org-left">tail-call</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bcall</td>
<td class="org-left">instruction stream</td>
<td class="org-left">short (16 bit) relative</td>
<td class="org-left">no</td>
</tr>

<tr>
<td class="org-left">btcall</td>
<td class="org-left">instruction stream</td>
<td class="org-left">short (16 bit) relative</td>
<td class="org-left">yes</td>
</tr>

<tr>
<td class="org-left">acall</td>
<td class="org-left">instruction stream</td>
<td class="org-left">full size absolute</td>
<td class="org-left">no</td>
</tr>

<tr>
<td class="org-left">scall</td>
<td class="org-left">top of stack</td>
<td class="org-left">full size absolute</td>
<td class="org-left">no</td>
</tr>

<tr>
<td class="org-left">stcall</td>
<td class="org-left">top of stack</td>
<td class="org-left">full size absolute</td>
<td class="org-left">yes</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> bcall: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">base-relative call </span><span style="color: #b22222;">*/</span>
<span style="color: #008b8b;">_bcall</span>:
   x = (cell)(BASE + *((<span style="color: #228b22;">short_jump_target</span> *)pc));  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
   pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
   <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> btcall:   <span style="color: #b22222;">/* </span><span style="color: #b22222;">base-relative tail-call, effectively a goto </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">if</span> (!tailcall) <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">_bcall</span>;
   x = (cell)(BASE + *((<span style="color: #228b22;">short_jump_target</span> *)pc));  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">tail_call</span>;
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> acall: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">absolute call </span><span style="color: #b22222;">*/</span>
   x = (cell) *((<span style="color: #228b22;">jump_target</span> *)pc);  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
   pc += <span style="color: #a020f0;">sizeof</span>(jump_target);
   <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> scall:
<span style="color: #008b8b;">_scall</span>:
   <span style="color: #b22222;">/* </span><span style="color: #b22222;">check if call target is primitive, if yes, substitute execution (tail call), since call only</span>
<span style="color: #b22222;">      applies to quotations </span><span style="color: #b22222;">*/</span>
   x = ppop();  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">if</span> (x &gt;= INSTBASE_CELL) {
      i = (x &gt;&gt; (8 * (<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span> *) - <span style="color: #a020f0;">sizeof</span>(inst))));
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">dispatch</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">calling a primitive "substitutes" the call with the primitive </span><span style="color: #b22222;">*/</span>
   } <span style="color: #a020f0;">else</span> {
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> stcall:
   <span style="color: #a020f0;">if</span> (!tailcall) <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">_scall</span>;
   x = ppop();  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">if</span> (x &gt;= INSTBASE_CELL) {
      i=( x &gt;&gt; (8 * (<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span>*) - <span style="color: #a020f0;">sizeof</span>(inst))));
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">dispatch</span>;      <span style="color: #b22222;">/* </span><span style="color: #b22222;">already a tail call </span><span style="color: #b22222;">*/</span>
   } <span style="color: #a020f0;">else</span> {
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">tail_call</span>;
   } <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
All the above jump outside of the switch statement, either to the <code>tailcall</code> or
<code>nestedcall</code> label.  These common execution paths are described next.
</p>

<p>
For normal nested calls, a stack frame is created that contains the return address and a
reference to the word being called.  This second item is not needed for execution, but
helps debugging since it always shows where the currently executed word was started.  If
debug mode is on, increase the nesting counter <code>debug_nest</code>.
</p>

<p>
Execution path <code>nested_call</code>:
</p>
<div class="org-src-container">

<pre class="src src-C">{
   <span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">next_word</span> = (<span style="color: #228b22;">inst</span> *) x;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">was set by the call instructions that jumped here </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">e</span> = {.return_address = pc, .current_call=next_word};
   returnpush(e);
   <span style="color: #a020f0;">if</span> (debug_mode) {
      <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">name</span> = find_by_address(next_word);
      debug_nest++;
      printf(<span style="color: #8b2252;">"calling: %s -&gt; %d\n"</span>,name,debug_nest);
   }
   pc=next_word;
}
<span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;
</pre>
</div>

<p>
For tail calls, the current word execution is just substituted (equivalent to a simple <code>jmp</code>)
</p>

<p>
Execution path <code>tail_call</code>:
</p>
<div class="org-src-container">

<pre class="src src-C">{
   <span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">next_word</span> = (<span style="color: #228b22;">inst</span> *) x;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">was set by the call instructions that jumped here </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">if</span> (debug_mode) {
      <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">name</span> = find_by_address(next_word);
      printf(<span style="color: #8b2252;">"tail calling: %s -&gt; %d\n"</span>,name,debug_nest);
   }
   pc = next_word;
}
<span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;
</pre>
</div>

<p>
<code>qend</code>, "quotation end", is the return instruction.  It pops a frame of the return stack
and sets the program counter to resume execution after the original call site.  Again, in
case of debug mode being activated, record the nesting level change.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> qend: {
   <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">e</span> = returnpop();
   <span style="color: #a020f0;">if</span> (debug_mode) {
      <span style="color: #a020f0;">if</span> (debug_nest &gt; 0) {
         printf(<span style="color: #8b2252;">"&lt;- %d\n"</span>,debug_nest);
         debug_nest--; }
      <span style="color: #a020f0;">else</span> {
         debug_mode=<span style="color: #008b8b;">false</span>; }
   }
   pc=e.return_address;
} <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline77" class="outline-5">
<h5 id="orgheadline77"><span class="section-number-5">4.6.3.9</span> Conditional</h5>
<div class="outline-text-5" id="text-4-6-3-9">
<p>
There is only one instruction for handling conditionals, which implements factor word <code>?</code>
directly.
</p>
<div class="org-src-container">

<pre class="src src-factor"><span style="color: #a020f0;">:</span> <span style="color: #0000ff;">?</span> <span style="color: #b22222;">( ? true false -- true/false )</span>
</pre>
</div>

<p>
If the flag (on third position) is false, leave only the <code>true</code> value, otherwise leave the
<code>false</code> value.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> truefalse:
   {
      <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">false_cons</span> = ppop();
      <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">true_cons</span> = ppop();
      <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">cond</span> = ppop();
      ppush(cond ? true_cons : false_cons);
   } <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline78" class="outline-5">
<h5 id="orgheadline78"><span class="section-number-5">4.6.3.10</span> Memory Access</h5>
<div class="outline-text-5" id="text-4-6-3-10">
<p>
These primitives write/read single values to/from memory.  Two are for byte-sized writes,
and the other two for cell-sized writes.
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> setmem:
        x = ppop();
        *((<span style="color: #228b22;">cell</span>*)x) = (ppop());
        <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> setmem8:
        x=ppop();
        *((<span style="color: #228b22;">char</span>*)x) = ((ppop() &amp; 0xff));
        <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> getmem: {
        <span style="color: #228b22;">cell</span> *<span style="color: #a0522d;">addr</span> = (<span style="color: #228b22;">cell</span> *)ppop();
        x = *addr;
        ppush(x);
} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> getmem8: {
        <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">addr</span> = (<span style="color: #228b22;">char</span> *)ppop();
        x = (<span style="color: #228b22;">cell</span>)(*(addr));
        ppush(x);
} <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline79" class="outline-5">
<h5 id="orgheadline79"><span class="section-number-5">4.6.3.11</span> Foreign Function Execution</h5>
<div class="outline-text-5" id="text-4-6-3-11">
<p>
For using foreign functions(see <a href="#orgtarget3">1.5</a>), these instructions are provided.
</p>

<p>
<code>ff</code> takes an index from the stack that points in to the <code>FF_Table</code>, which is generated in
<code>bytecode.c</code> along the image and the dictionary from the <code>ff.yml</code> specification.  This
table holds all the function addresses that have been made available.  <code>ff</code> returns this
address.
</p>

<p>
The mfactor code that actually makes use of these primitives is generated in
<code>generated/ff.mfactor</code>.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> ff: {
<span style="color: #483d8b;">   #if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> FF_LENGTH
<span style="color: #483d8b;">      #define</span> <span style="color: #a0522d;">FF_LENGTH</span> 0
<span style="color: #483d8b;">   #endif</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = ppop();
   <span style="color: #a020f0;">if</span> (i &gt;= FF_LENGTH)
   {
      printf(<span style="color: #8b2252;">"no ff entry with index %i\n"</span>,i);
      BACKTRACE();
      handle_error(INTERNAL_ERROR_UNKNOWN_FF);
   }
   ppush((<span style="color: #228b22;">cell</span>)FF_Table[i]);
} <span style="color: #a020f0;">break</span>;
</pre>
</div>

<p>
The <code>ccall*</code> primitives are then used to actually call the function pointed to by
above-obtained address.  Instead of providing support for each architcture's full calling
convention, the c compiler is used to generate correct call frames by casting the function
address to one more common function prototypes.  The name of the <code>ccall_*</code> indicates which
calling convention should be used.
</p>

<p>
All these primitives return a value, even if the underlying c function is declared with a
<code>void</code> return type.  It is up to the generated code in <code>generated/ff.mfactor</code> to correctly
drop these junk values.
</p>

<p>
This is a speed/space tradeoff, since all these instructions do similar things, but
computing a call frame for the underlying call convention would be more expensive, in
addition to somehow providing the information about the argument number and types.
</p>

<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> ccall_i:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_s:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">short</span>))ppop();
      <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s1</span> = (<span style="color: #228b22;">short</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(s1);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_b:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">char</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">char</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b1</span> = (<span style="color: #228b22;">char</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(b1);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_bi:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">char</span>, <span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">char</span> <span style="color: #a0522d;">b1</span> = (<span style="color: #228b22;">char</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(b1,i2);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_ib:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>, <span style="color: #228b22;">char</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>, <span style="color: #228b22;">char</span>))ppop();
      <span style="color: #228b22;">char</span> <span style="color: #a0522d;">b2</span> = (<span style="color: #228b22;">char</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,b2);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_is:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>))ppop();
      <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s2</span> = (<span style="color: #228b22;">short</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,s2);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_iis:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>))ppop();
      <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s3</span> = (<span style="color: #228b22;">short</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2,s3);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_iii:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i3</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2,i3);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_ii:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2);
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_v:
   {
      <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">void</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">void</span>))ppop();
      <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun();
      ppush((<span style="color: #228b22;">cell</span>)res);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> ccall_lit: <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">address is literal, nothing happens </span><span style="color: #b22222;">*/</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline80" class="outline-5">
<h5 id="orgheadline80"><span class="section-number-5">4.6.3.12</span> (As of Yet) Undocumented instructions</h5>
<div class="outline-text-5" id="text-4-6-3-12">
<div class="org-src-container">

<pre class="src src-C"><span style="color: #a020f0;">case</span> nop: <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> dref:
   x=(cell)(*((<span style="color: #228b22;">short_jump_target</span>*) pc));
   ppush((<span style="color: #228b22;">cell</span>)memory+x);
   pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> bref:              <span style="color: #b22222;">/* </span><span style="color: #b22222;">reference to short-length in-memory data (type can be seen on-site)</span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">case</span> blitq:             <span style="color: #b22222;">/* </span><span style="color: #b22222;">deprecated </span><span style="color: #b22222;">*/</span>
   x=(<span style="color: #228b22;">cell</span>)(*((<span style="color: #228b22;">short_jump_target</span>*) pc));
   ppush((<span style="color: #228b22;">cell</span>) (BASE + ((<span style="color: #228b22;">short_jump_target</span>) x)));
   pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> quit:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">quit the interpreter, returning 0 </span><span style="color: #b22222;">*/</span>
   printf(<span style="color: #8b2252;">"quitting interpreter!\n"</span>);
   <span style="color: #a020f0;">return</span> 0;
<span style="color: #a020f0;">case</span> token: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">get one token from standard input </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">tok</span> = read_token();
   <span style="color: #a020f0;">if</span> (tok) {
      ppush((<span style="color: #228b22;">cell</span>)tok);
   } <span style="color: #a020f0;">else</span> {
      print_error(<span style="color: #8b2252;">"token reader error"</span>);
      handle_error(INTERNAL_ERROR_TOKEN_READ);
   }} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> lookup_name: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">provide a search start for the name (addr length) by using</span>
<span style="color: #b22222;">                      * the hash table lookup </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">length</span> = ppop();
   <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">name</span> = ppop();
   ppush(lookup_ht_entry((<span style="color: #228b22;">uint8_t</span>) length,(<span style="color: #228b22;">char</span> *) name)); }
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> error:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">trigger internal error (bypasses any exception handling) </span><span style="color: #b22222;">*/</span>
   printf(<span style="color: #8b2252;">"error!\n"</span>);
   printf(<span style="color: #8b2252;">"\np"</span>);
   printstack(psp,pstack);
   printf(<span style="color: #8b2252;">"retain"</span>);
   printstack(retainsp,retainstack);
   printf(<span style="color: #8b2252;">"return"</span>);
   print_return_stack(returnsp,returnstack,(<span style="color: #228b22;">inst</span> *)BASE);
   BACKTRACE();
   handle_error(INTERNAL_ERROR_GENERAL);
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> tstart:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">start the timer </span><span style="color: #b22222;">*/</span>
   start_timer();
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> tend:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">end the timer, return measurement results ( -- usecs secs ) </span><span style="color: #b22222;">*/</span>
   {
      <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sec</span>,<span style="color: #a0522d;">usec</span>;
      end_timer(&amp;sec,&amp;usec);
      ppush(usec);
      ppush(sec);
   } <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> parsenum: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">parse the (c)string at the address on top of stack as number </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span> = (<span style="color: #228b22;">char</span> *)ppop();
   <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">num</span> = 0xa5a5a5a5;
   <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">success</span>=parse_number(str+1,&amp;num);
   ppush(success ? num : (<span style="color: #228b22;">cell</span>) str);
   ppush((<span style="color: #228b22;">cell</span>)success);
} <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> tail:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">activate tail call elimination </span><span style="color: #b22222;">*/</span>
   tailcall=<span style="color: #008b8b;">true</span>; <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> notail:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">deactivate tail call elimination </span><span style="color: #b22222;">*/</span>
   tailcall=<span style="color: #008b8b;">false</span>; <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> reset:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">call externally refined system-reset </span><span style="color: #b22222;">*/</span>
   reset_system();
   <span style="color: #a020f0;">break</span>;
<span style="color: #a020f0;">case</span> debug:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">activate debug mode </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">if</span> (!debug_mode) {
      debug_mode=<span style="color: #008b8b;">true</span>;
   } <span style="color: #a020f0;">break</span>;
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline85" class="outline-2">
<h2 id="orgheadline85"><span class="section-number-2">5</span> Appendix: Complete Sources</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgheadline83" class="outline-3">
<h3 id="orgheadline83"><span class="section-number-3">5.1</span> interpreter.h</h3>
<div class="outline-text-3" id="text-5-1">
<div class="org-src-container">

<pre class="src src-C" id="orgsrcblock1"><span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> INTERPRETER_H
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERPRETER_H</span>

<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdint.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"generated/bytecode.h"</span>

<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #228b22;">inst</span>;
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">short</span> <span style="color: #228b22;">short_jump_target</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">relative jumps in 64k on 32 bit </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">uintptr_t</span> <span style="color: #228b22;">jump_target</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">long absolute jump </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #228b22;">uintptr_t</span> <span style="color: #228b22;">cell</span>;                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">memory cell must at least hold pointer </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">dict_entry</span>
{
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">address</span>;           <span style="color: #b22222;">/* </span><span style="color: #b22222;">pointer into memory </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">flags</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">may include other flags later (inline, recursive, etc) </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name_header</span>;      <span style="color: #b22222;">/* </span><span style="color: #b22222;">should always be zero </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name_length</span>;
   <span style="color: #228b22;">char</span> <span style="color: #a0522d;">name</span>[];
} <span style="color: #a020f0;">__attribute__</span>((<span style="color: #228b22;">packed</span>)) <span style="color: #228b22;">dict_entry</span>;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">data memory (affects non-transient data) in cells</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_MEM
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_MEM</span> 256
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">dictionary size (affects number of named items)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_DICT
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_DICT</span> 512
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">parameter stack size (affects transient data)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_PSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_PSTACK</span> 64
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">return stack size (affects nesting of functions)</span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_RETURNSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_RETURNSTACK</span> 64
<span style="color: #483d8b;">#endif</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">retain stack size (affects maximum amount of postponing data use) </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> VM_RETAINSTACK
<span style="color: #483d8b;">        #define</span> <span style="color: #a0522d;">VM_RETAINSTACK</span> 32
<span style="color: #483d8b;">#endif</span>
<span style="color: #483d8b;">#if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> INSTBASE
<span style="color: #483d8b;"> #if</span> (__linux &amp;&amp; __LP64__)
<span style="color: #483d8b;">  #define</span> <span style="color: #a0522d;">INSTBASE</span> 0x80U
<span style="color: #483d8b;"> #elif</span> (CORTEX_M)
<span style="color: #483d8b;">  #define</span> <span style="color: #a0522d;">INSTBASE</span> 0xA0U
<span style="color: #483d8b;"> #else</span>
<span style="color: #483d8b;">  #error</span> <span style="color: #8b2252;">"don't know instruction code base for architecure!"</span>
<span style="color: #483d8b;"> #endif</span>
<span style="color: #483d8b;">#endif</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INSTBASE_CELL</span> ((<span style="color: #228b22;">cell</span>)INSTBASE&lt;&lt;(8*(<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span> *)-<span style="color: #a020f0;">sizeof</span>(inst))))
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">inst</span> <span style="color: #a0522d;">image</span>[];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">dict_entry</span> <span style="color: #a0522d;">dict</span>[VM_DICT];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">uint16_t</span> <span style="color: #a0522d;">dict_hash_index</span>[];
<span style="color: #a020f0;">extern</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">FF_Table</span>[];
<span style="color: #b22222;">/* </span><span style="color: #b22222;">these values can be returned from interpreter() </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_PSTACK_UFLOW</span> -1
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_PSTACK_OFLOW</span> -2
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RSTACK_UFLOW</span> -3
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RSTACK_OFLOW</span> -4
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RTSTACK_UFLOW</span> -5
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_RTSTACK_OFLOW</span> -6
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_INVALID_OPCODE</span> -7
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_MEM_FAULT</span> -8
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_UNKNOWN_FF</span> -9
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_TOKEN_READ</span> -10
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_GENERAL</span> -11
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">INTERNAL_ERROR_UNKNOWN_SPECIAL</span> -12
<span style="color: #228b22;">int</span> <span style="color: #0000ff;">interpreter</span>(<span style="color: #228b22;">short_jump_target</span>);

<span style="color: #483d8b;">#endif</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline84" class="outline-3">
<h3 id="orgheadline84"><span class="section-number-3">5.2</span> interpreter.c</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-C" id="orgsrcblock2"><span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"interpreter.h"</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"reader.h"</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;string.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stddef.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdio.h&gt;</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">&lt;stdbool.h&gt;</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">these are available after mfactor task has run </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"generated/bytecode.h"</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"generated/inst_enum.h"</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">target specific stuff </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"runtime.h"</span>
<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"reset_system.h"</span>

<span style="color: #483d8b;">#include</span> <span style="color: #8b2252;">"seq_headers.h"</span>

<span style="color: #b22222;">/* </span><span style="color: #b22222;">main memory to work with </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">memory</span>[VM_MEM];
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">_NumSpecials</span> 10
<span style="color: #a020f0;">static</span> <span style="color: #a020f0;">const</span> <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">NumSpecials</span> = _NumSpecials;
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">special_vars</span>[_NumSpecials];
<span style="color: #b22222;">/* </span><span style="color: #b22222;">currently implemented special variables</span>
<span style="color: #b22222;">0: MP - memory write pointer</span>
<span style="color: #b22222;">1: HANDLER - handler frame location in r(etain) stack (dynamic chain for catch frames)</span>
<span style="color: #b22222;">2: DEBUG_LEVEL - 0 to turn off, increasing will produce more verbose debug output</span>
<span style="color: #b22222;">3: RESTART - word where to restart when hard error occured</span>
<span style="color: #b22222;">4: STEP_HANDLER - address of handler which can be used for single stepping</span>
<span style="color: #b22222;">5: BASE - address of current 64k segment base</span>
<span style="color: #b22222;">6: OUTPUT_STREAM: 1: stdout, 2: stderr, 3: null</span>
<span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">MP</span> special_vars[0]
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">HANDLER</span> special_vars[1]
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">DEBUG_LEVEL</span> special_vars[2]
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">BASE</span> special_vars[5]
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">OUTPUT_STREAM</span> special_vars[6]
<span style="color: #b22222;">/* </span><span style="color: #b22222;">known stream descriptors for OUTPUT_STREAM </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STDOUT</span> 1
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">STDERR</span> 2
<span style="color: #483d8b;">#define</span> <span style="color: #a0522d;">NULLOUT</span> 3
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">init_specials</span>() {
   HANDLER = 0;
   MP = (<span style="color: #228b22;">cell</span>)memory; <span style="color: #b22222;">/* </span><span style="color: #b22222;">start of user memory </span><span style="color: #b22222;">*/</span>
   BASE = (<span style="color: #228b22;">cell</span>)&amp;image; <span style="color: #b22222;">/* </span><span style="color: #b22222;">start of bytecode segment </span><span style="color: #b22222;">*/</span>
   OUTPUT_STREAM = STDOUT; <span style="color: #b22222;">/* </span><span style="color: #b22222;">output to standard output per default </span><span style="color: #b22222;">*/</span>
}
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">Ostream</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">used by reporting functions, so they can temporarily</span>
<span style="color: #b22222;">                          print to different file descriptor </span><span style="color: #b22222;">*/</span>


<span style="color: #b22222;">/* </span><span style="color: #b22222;">get the current stdio FILE from the special variable, or NULL if unknown or muted by</span>
<span style="color: #b22222;"> * choosing NULLOUT </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">FILE</span> * <span style="color: #0000ff;">current_fd</span>(<span style="color: #228b22;">void</span>)
{
        <span style="color: #a020f0;">if</span> (OUTPUT_STREAM == 2)
                <span style="color: #a020f0;">return</span> stderr;
        <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> (OUTPUT_STREAM == 1)
                <span style="color: #a020f0;">return</span> stdout;
        <span style="color: #a020f0;">else</span>
                <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">NULL</span>;
}
<span style="color: #a020f0;">typedef</span> <span style="color: #a020f0;">struct</span> <span style="color: #228b22;">return_entry</span> {
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">return_address</span>;
   <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">current_call</span>;
} <span style="color: #228b22;">return_entry</span>;
<span style="color: #228b22;">uint32_t</span> <span style="color: #0000ff;">lookup_ht_entry</span>(<span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">length</span>, <span style="color: #228b22;">char</span>* <span style="color: #a0522d;">name</span>) {
   <span style="color: #228b22;">uint32_t</span> <span style="color: #a0522d;">hash</span> = 5381;
   <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = 0; i &lt; length; i++) {
      hash = hash * 33 + name[i];
   }
   <span style="color: #a020f0;">return</span> (<span style="color: #228b22;">cell</span>)dict+dict_hash_index[hash%256];
}
<span style="color: #b22222;">/* </span><span style="color: #b22222;">get the name of the word, only for debugging </span><span style="color: #b22222;">*/</span>
<span style="color: #b22222;">/* </span><span style="color: #b22222;">probably fails for non-null-terminated strings </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">char</span>* <span style="color: #0000ff;">find_by_address</span>( <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">word</span>)
{
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">notfound</span>[] = <span style="color: #8b2252;">"(internal or private)"</span>;
   <span style="color: #a020f0;">for</span> (<span style="color: #228b22;">char</span> * <span style="color: #a0522d;">ptr</span>=(<span style="color: #228b22;">char</span>*)dict;
        (ptr &lt; ((<span style="color: #228b22;">char</span>*)dict+<span style="color: #a020f0;">sizeof</span>(dict)))&amp;&amp;(((<span style="color: #228b22;">dict_entry</span>*)ptr)-&gt;name_length &gt; 0);
        ptr += (((<span style="color: #228b22;">dict_entry</span>*)ptr)-&gt;name_length + 3*<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>) + <span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">void</span>*))) {
      <span style="color: #228b22;">dict_entry</span> *<span style="color: #a0522d;">dptr</span> = (<span style="color: #228b22;">dict_entry</span>*)ptr;
      <span style="color: #a020f0;">if</span> (dptr-&gt;address == word)
         <span style="color: #a020f0;">return</span> dptr-&gt;name;
   }
   <span style="color: #a020f0;">return</span> notfound;
}
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">bool</span> <span style="color: #0000ff;">parse_number</span>(<span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span>, <span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">number</span>){
   <span style="color: #228b22;">int</span> <span style="color: #a0522d;">num</span>;
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">read</span> = sscanf(str,<span style="color: #8b2252;">"%i"</span>,&amp;num);
   <span style="color: #a020f0;">if</span> (read == 1) {
      *number = (<span style="color: #228b22;">cell</span>)num;
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
   } <span style="color: #a020f0;">else</span> {
      <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
   }
}
<span style="color: #b22222;">/* </span><span style="color: #b22222;">display data stack entries </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">printstack</span>(<span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">cell</span> * <span style="color: #a0522d;">stack</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"stack:"</span>);
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">ptr</span> = stack;ptr &lt; sp;ptr++)
   {
      fprintf(Ostream, <span style="color: #8b2252;">" %#lx"</span>,*ptr);
   }
   fprintf(Ostream, <span style="color: #8b2252;">"\n"</span>);
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">display return stack entries </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_return_stack</span>(<span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">base</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"stack:"</span>);
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">ptr</span> = sp-1;ptr &gt;= stack;ptr--)
   {
      fprintf(Ostream, <span style="color: #8b2252;">" {%#lx-&gt;%#lx}"</span>,((<span style="color: #228b22;">uintptr_t</span>)ptr-&gt;current_call-(<span style="color: #228b22;">uintptr_t</span>)base),
              ((<span style="color: #228b22;">uintptr_t</span>)ptr-&gt;return_address)-(<span style="color: #228b22;">uintptr_t</span>) base);
   }
   fprintf(Ostream, <span style="color: #8b2252;">"\n"</span>);
}

<span style="color: #b22222;">/* </span><span style="color: #b22222;">print a backtrace of the return stack </span><span style="color: #b22222;">*/</span>
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">backtrace</span>(<span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">sp</span>, <span style="color: #228b22;">return_entry</span> * <span style="color: #a0522d;">stack</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">base</span>, <span style="color: #228b22;">inst</span> * <span style="color: #a0522d;">pc</span>)
{
   fprintf(Ostream, <span style="color: #8b2252;">"backtrace @ %#lx:\n"</span>,(<span style="color: #228b22;">uintptr_t</span>)(pc-base));
   <span style="color: #a020f0;">for</span>(<span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">ptr</span> = sp-1;ptr &gt;= stack;ptr--)
   {
      <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">current_name</span> = find_by_address(ptr-&gt;current_call);
      fprintf(Ostream, <span style="color: #8b2252;">"%#lx %s\n"</span>,(<span style="color: #228b22;">uintptr_t</span>)(ptr-&gt;current_call - base),current_name);
   }
}
<span style="color: #a020f0;">static</span> <span style="color: #228b22;">void</span> <span style="color: #0000ff;">print_error</span>(<span style="color: #228b22;">char</span> * <span style="color: #a0522d;">str</span>)
{
   fprintf(stderr, <span style="color: #8b2252;">"error: "</span>);
   fprintf(stderr, str);
   fprintf(stderr, <span style="color: #8b2252;">"\n"</span>);
}
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">BACKTRACE</span>() <span style="color: #a020f0;">do</span> {                                 \
      <span style="color: #228b22;">FILE</span> * <span style="color: #a0522d;">old_out</span> = Ostream;                          \
      Ostream = stderr;                                  \
      printstack(psp,pstack);                            \
      printstack(retainsp,retainstack);                  \
      backtrace(returnsp,returnstack,(<span style="color: #228b22;">inst</span> *)BASE,pc);   \
      Ostream = old_out;                                 \
   }       <span style="color: #a020f0;">while</span> (0)
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">handle_error</span>(<span style="color: #a0522d;">code</span>) <span style="color: #a020f0;">do</span> {<span style="color: #a020f0;">return</span> code;} <span style="color: #a020f0;">while</span>(0)
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">assert_pop</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">min</span>,<span style="color: #a0522d;">name</span>,<span style="color: #a0522d;">fail_reason</span>) <span style="color: #a020f0;">if</span> (sp &lt;= min) { print_error(name <span style="color: #8b2252;">"stack underflow"</span>);BACKTRACE();handle_error(fail_reason);}
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">assert_push</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">min</span>,<span style="color: #a0522d;">size</span>,<span style="color: #a0522d;">fail_reason</span>) <span style="color: #a020f0;">if</span> (sp &gt; min+size){ print_error(<span style="color: #8b2252;">"stack overflow"</span>);BACKTRACE();handle_error(fail_reason);}
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">peek_n</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">nth</span>) (*(sp-nth))
<span style="color: #b22222;">/* </span><span style="color: #b22222;">push value onto stack indicated by stack pointer sp </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">push_</span>(<span style="color: #a0522d;">sp</span>,<span style="color: #a0522d;">val</span>) *sp=val;sp++;
<span style="color: #b22222;">/* </span><span style="color: #b22222;">pop value from stack indicated by stack pointer sp </span><span style="color: #b22222;">*/</span>
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">pop_</span>(<span style="color: #a0522d;">sp</span>) --sp;*sp;
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ppush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(psp,pstack,VM_PSTACK,INTERNAL_ERROR_PSTACK_OFLOW);push_(psp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">ppop</span>() ({assert_pop(psp,pstack,<span style="color: #8b2252;">"p"</span>,INTERNAL_ERROR_PSTACK_UFLOW);pop_(psp)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">returnpush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(returnsp,returnstack,VM_RETURNSTACK,INTERNAL_ERROR_RSTACK_OFLOW);push_(returnsp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">returnpop</span>() ({assert_pop(returnsp,returnstack,<span style="color: #8b2252;">"return"</span>,INTERNAL_ERROR_RSTACK_UFLOW);pop_(returnsp)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">retainpush</span>(<span style="color: #a0522d;">val</span>) ({assert_push(retainsp,retainstack,VM_RETAINSTACK,INTERNAL_ERROR_RTSTACK_OFLOW);push_(retainsp,val)})
<span style="color: #483d8b;">#define</span> <span style="color: #0000ff;">retainpop</span>() ({assert_pop(retainsp,retainstack,<span style="color: #8b2252;">"retain"</span>,INTERNAL_ERROR_RTSTACK_OFLOW);pop_(retainsp)})

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">interpreter</span>(<span style="color: #228b22;">short_jump_target</span> <span style="color: #a0522d;">start_address</span>) {

   <span style="color: #b22222;">/* </span><span style="color: #b22222;">parameter stack </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">pstack</span>[VM_PSTACK]={0};
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">psp</span>;
   psp = &amp;pstack[0];
   <span style="color: #b22222;">/* </span><span style="color: #b22222;">return stack </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">returnstack</span>[VM_RETURNSTACK]={{0}};
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">return_entry</span>* <span style="color: #a0522d;">returnsp</span>;
   returnsp = &amp;returnstack[0];
   <span style="color: #b22222;">/* </span><span style="color: #b22222;">retain stack </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">retainstack</span>[VM_RETAINSTACK]={0};
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">retainsp</span>;
   retainsp = &amp;retainstack[0];
   <span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">pc</span>;
   pc = &amp;image[(start_address ? : START_WORD_OFFSET)];  <span style="color: #b22222;">/* </span><span style="color: #b22222;">point to the start of the program </span><span style="color: #b22222;">*/</span>
   <span style="color: #a020f0;">static</span> <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">tailcall</span>;
   tailcall = <span style="color: #008b8b;">true</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">enable tail call jumping by default </span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">x</span>; <span style="color: #b22222;">/* </span><span style="color: #b22222;">temporary value for operations </span><span style="color: #b22222;">*/</span>
   <span style="color: #b22222;">/* </span><span style="color: #b22222;">single step debugging</span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">debug_nest</span> = 0; <span style="color: #b22222;">/* </span><span style="color: #b22222;">used in debug mode to track when</span>
<span style="color: #b22222;">                                 * to stop single stepping</span><span style="color: #b22222;">*/</span>
   <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">debug_mode</span> = <span style="color: #008b8b;">false</span>;
<span style="color: #483d8b;">   #if</span> DEBUG
   debug_mode=<span style="color: #008b8b;">true</span>;
<span style="color: #483d8b;">   #endif</span>

   Ostream = stdout;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">print everything to stdout per default </span><span style="color: #b22222;">*/</span>
   init_specials();

   <span style="color: #a020f0;">while</span>(1) {
      <span style="color: #228b22;">inst</span> <span style="color: #a0522d;">i</span>;
      i = (*pc++);
   <span style="color: #008b8b;">dispatch</span>:

      <span style="color: #a020f0;">switch</span>(i) {
         <span style="color: #a020f0;">case</span> drop: ppop(); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> _dup: ppush(peek_n(psp,1)); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> swap: {
            x=ppop();
            <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">y</span> = ppop();
            ppush(x);
            ppush(y);
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> to_r: retainpush(ppop()); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> r_from: ppush(retainpop()); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> clear: psp = &amp;pstack[0]; <span style="color: #a020f0;">break</span>;
<span style="color: #483d8b;">         #define</span> <span style="color: #0000ff;">UNOP</span>(<span style="color: #a0522d;">op</span>) {                              \
               x=(op ((<span style="color: #228b22;">intptr_t</span>) ppop()));               \
               ppush(x);                                 \
            } <span style="color: #a020f0;">break</span>
<span style="color: #483d8b;">         #define</span> <span style="color: #0000ff;">BINOP</span>(<span style="color: #a0522d;">op</span>) {                                                     \
               x = ppop();                                                       \
               <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">y</span> = ppop();                                                  \
               ppush(((<span style="color: #228b22;">intptr_t</span>)y) op ((<span style="color: #228b22;">intptr_t</span>)x));                            \
            } <span style="color: #a020f0;">break</span>
         <span style="color: #a020f0;">case</span> add: BINOP(+); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> mul: <span style="color: #228b22;">BINOP</span>(*); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> sub: BINOP(-); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> neg: UNOP(-); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> asl: BINOP(&lt;&lt;); <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">arithmetic shift left </span><span style="color: #b22222;">*/</span>
         <span style="color: #a020f0;">case</span> asr: BINOP(&gt;&gt;); <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">arithmetic shift right </span><span style="color: #b22222;">*/</span>
         <span style="color: #a020f0;">case</span> div: BINOP(/); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> mod: BINOP(%); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bitand: BINOP(&amp;); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bitor: BINOP(|); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bitxor: BINOP(^); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bitnot: UNOP(~); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> gt: BINOP(&gt;); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> lt: BINOP(&lt;); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> eql: BINOP(==); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> zero: ppush(0); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> one: ppush(1); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> two: ppush(2); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> memstart: ppush((<span style="color: #228b22;">cell</span>)memory); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> memend: ppush((<span style="color: #228b22;">cell</span>)(memory+VM_MEM)); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> memrange:
            ppush((<span style="color: #228b22;">cell</span>) memory);
            ppush((<span style="color: #228b22;">cell</span>) memory+VM_MEM*<span style="color: #a020f0;">sizeof</span>(cell));
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> dictstart: ppush((<span style="color: #228b22;">cell</span>)dict); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> dictend: ppush((<span style="color: #228b22;">cell</span>)(dict+VM_DICT)); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> cellsize: ppush((<span style="color: #228b22;">cell</span>)<span style="color: #a020f0;">sizeof</span>(cell)); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> instbase: ppush((<span style="color: #228b22;">cell</span>)INSTBASE); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> get_sp:
            <span style="color: #a020f0;">switch</span> (ppop()) {
               <span style="color: #a020f0;">case</span> 0 : ppush((<span style="color: #228b22;">cell</span>)psp); <span style="color: #a020f0;">break</span>;
               <span style="color: #a020f0;">case</span> 1 : ppush((<span style="color: #228b22;">cell</span>)retainsp); <span style="color: #a020f0;">break</span>;
               <span style="color: #a020f0;">case</span> 2 : ppush((<span style="color: #228b22;">cell</span>)returnsp); <span style="color: #a020f0;">break</span>;
               <span style="color: #a020f0;">default</span>: ppush((<span style="color: #228b22;">cell</span>)0); <span style="color: #a020f0;">break</span>;
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> set_sp:
            {
               <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">n</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
               <span style="color: #228b22;">cell</span>* <span style="color: #a0522d;">newsp</span> = (<span style="color: #228b22;">cell</span>*)ppop();
               <span style="color: #a020f0;">switch</span> (n) {
                  <span style="color: #a020f0;">case</span> 0 : psp = newsp; <span style="color: #a020f0;">break</span>;
                  <span style="color: #a020f0;">case</span> 1 : retainsp = newsp; <span style="color: #a020f0;">break</span>;
                  <span style="color: #a020f0;">case</span> 2 : returnsp = (<span style="color: #228b22;">return_entry</span> *)newsp; <span style="color: #a020f0;">break</span>;
               }
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> get_special:
            {
               <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">i</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
               <span style="color: #a020f0;">if</span> (i &lt; NumSpecials)
                  ppush(special_vars[i]);
               <span style="color: #a020f0;">else</span> {
                  printf(<span style="color: #8b2252;">"illegal specials index: %d\n"</span>, i);
                  handle_error(INTERNAL_ERROR_UNKNOWN_SPECIAL);
               }
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> set_special:
            {
               <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span> <span style="color: #a0522d;">i</span> = (<span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">char</span>)ppop();
               <span style="color: #a020f0;">if</span> (i &lt; NumSpecials)
                  special_vars[i] = ppop();
               <span style="color: #a020f0;">else</span> {
                  printf(<span style="color: #8b2252;">"illegal specials index: %d\n"</span>, i);
                  handle_error(INTERNAL_ERROR_UNKNOWN_SPECIAL);
               }
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> stack_level: ppush(psp-pstack); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> litb:              <span style="color: #b22222;">/* </span><span style="color: #b22222;">byte literal </span><span style="color: #b22222;">*/</span>
           x=(<span style="color: #228b22;">cell</span>)(*(pc++));
           ppush(x);
           <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ref:
         <span style="color: #a020f0;">case</span> liti:               <span style="color: #b22222;">/* </span><span style="color: #b22222;">cell-wide literal </span><span style="color: #b22222;">*/</span>
           x=*((<span style="color: #228b22;">cell</span> *)pc);
           ppush(x);
           pc+=<span style="color: #a020f0;">sizeof</span>(cell);
           <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> litc: {              <span style="color: #b22222;">/* </span><span style="color: #b22222;">complex inline literal </span><span style="color: #b22222;">*/</span>
           <span style="color: #b22222;">/* </span><span style="color: #b22222;">pc is already at the next item -&gt; header byte </span><span style="color: #b22222;">*/</span>
           <span style="color: #228b22;">seq_header</span> <span style="color: #a0522d;">h</span> = (<span style="color: #228b22;">seq_header</span>)(*pc);
           ppush((<span style="color: #228b22;">cell</span>)pc+1);    <span style="color: #b22222;">/* </span><span style="color: #b22222;">leave address of count byte on stack </span><span style="color: #b22222;">*/</span>
           pc += 2 + fe_seq_size(h,pc+1);
           } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> oplit:             <span style="color: #b22222;">/* </span><span style="color: #b22222;">literal primitive operation </span><span style="color: #b22222;">*/</span>
            x=(<span style="color: #228b22;">cell</span>)*(pc++);
            ppush(x&lt;&lt;(8*(<span style="color: #a020f0;">sizeof</span>(cell)-<span style="color: #a020f0;">sizeof</span>(inst))));
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> qstart: {
            <span style="color: #228b22;">uint8_t</span> <span style="color: #a0522d;">l</span> = *((<span style="color: #228b22;">uint8_t</span> *)pc) + 1;
            ppush((<span style="color: #228b22;">cell</span>)(pc + 1));
            <span style="color: #b22222;">/* </span><span style="color: #b22222;">skip over quotation length and count byte, leaving pc after qend </span><span style="color: #b22222;">*/</span>
            pc = pc + l + 1;
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> emit:
            <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>) {
               fputc(ppop(),current_fd());
               fflush(stdout);                 <span style="color: #b22222;">/* </span><span style="color: #b22222;">TODO remove when flushing is delegated to</span>
<span style="color: #b22222;">                                                * higher level calls </span><span style="color: #b22222;">*/</span>
            } <span style="color: #a020f0;">else</span>
               (<span style="color: #228b22;">void</span>) ppop();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> receive:
            ppush(read_char()); <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> _pwrite:
            <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
               fprintf(current_fd(), <span style="color: #8b2252;">"%ld"</span>, ppop());
            <span style="color: #a020f0;">else</span>
               (<span style="color: #228b22;">void</span>) ppop();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> pwritex:
            <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
               fprintf(current_fd(), <span style="color: #8b2252;">"%#lx"</span>, ppop());
            <span style="color: #a020f0;">else</span>
               (<span style="color: #228b22;">void</span>) ppop();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> writex:
            <span style="color: #a020f0;">if</span> (current_fd() != <span style="color: #008b8b;">NULL</span>)
               fprintf(current_fd(), <span style="color: #8b2252;">"%lx"</span>, ppop());
            <span style="color: #a020f0;">else</span>
               (<span style="color: #228b22;">void</span>) ppop();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bcall: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">base-relative call </span><span style="color: #b22222;">*/</span>
         <span style="color: #008b8b;">_bcall</span>:
            x = (<span style="color: #228b22;">cell</span>)(BASE + *((<span style="color: #228b22;">short_jump_target</span> *)pc));  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
            pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> btcall:   <span style="color: #b22222;">/* </span><span style="color: #b22222;">base-relative tail-call, effectively a goto </span><span style="color: #b22222;">*/</span>
            <span style="color: #a020f0;">if</span> (!tailcall) <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">_bcall</span>;
            x = (<span style="color: #228b22;">cell</span>)(BASE + *((<span style="color: #228b22;">short_jump_target</span> *)pc));  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">tail_call</span>;
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> acall: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">absolute call </span><span style="color: #b22222;">*/</span>
            x = (<span style="color: #228b22;">cell</span>) *((<span style="color: #228b22;">jump_target</span> *)pc);  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
            pc += <span style="color: #a020f0;">sizeof</span>(jump_target);
            <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> scall:
         <span style="color: #008b8b;">_scall</span>:
            <span style="color: #b22222;">/* </span><span style="color: #b22222;">check if call target is primitive, if yes, substitute execution (tail call), since call only</span>
<span style="color: #b22222;">               applies to quotations </span><span style="color: #b22222;">*/</span>
            x = ppop();  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
            <span style="color: #a020f0;">if</span> (x &gt;= INSTBASE_CELL) {
               i = (x &gt;&gt; (8 * (<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span> *) - <span style="color: #a020f0;">sizeof</span>(inst))));
               <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">dispatch</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">calling a primitive "substitutes" the call with the primitive </span><span style="color: #b22222;">*/</span>
            } <span style="color: #a020f0;">else</span> {
               <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">nested_call</span>;
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> stcall:
            <span style="color: #a020f0;">if</span> (!tailcall) <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">_scall</span>;
            x = ppop();  <span style="color: #b22222;">/* </span><span style="color: #b22222;">set the target </span><span style="color: #b22222;">*/</span>
            <span style="color: #a020f0;">if</span> (x &gt;= INSTBASE_CELL) {
               i=( x &gt;&gt; (8 * (<span style="color: #a020f0;">sizeof</span>(<span style="color: #228b22;">inst</span>*) - <span style="color: #a020f0;">sizeof</span>(inst))));
               <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">dispatch</span>;      <span style="color: #b22222;">/* </span><span style="color: #b22222;">already a tail call </span><span style="color: #b22222;">*/</span>
            } <span style="color: #a020f0;">else</span> {
               <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">tail_call</span>;
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> qend: {
            <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">e</span> = returnpop();
            <span style="color: #a020f0;">if</span> (debug_mode) {
               <span style="color: #a020f0;">if</span> (debug_nest &gt; 0) {
                  printf(<span style="color: #8b2252;">"&lt;- %d\n"</span>,debug_nest);
                  debug_nest--; }
               <span style="color: #a020f0;">else</span> {
                  debug_mode=<span style="color: #008b8b;">false</span>; }
            }
            pc=e.return_address;
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> truefalse:
            {
               <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">false_cons</span> = ppop();
               <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">true_cons</span> = ppop();
               <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">cond</span> = ppop();
               ppush(cond ? true_cons : false_cons);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> setmem:
                 x = ppop();
                 *((<span style="color: #228b22;">cell</span>*)x) = (ppop());
                 <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> setmem8:
                 x=ppop();
                 *((<span style="color: #228b22;">char</span>*)x) = ((ppop() &amp; 0xff));
                 <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> getmem: {
                 <span style="color: #228b22;">cell</span> *<span style="color: #a0522d;">addr</span> = (<span style="color: #228b22;">cell</span> *)ppop();
                 x = *addr;
                 ppush(x);
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> getmem8: {
                 <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">addr</span> = (<span style="color: #228b22;">char</span> *)ppop();
                 x = (<span style="color: #228b22;">cell</span>)(*(addr));
                 ppush(x);
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ff: {
<span style="color: #483d8b;">            #if</span><span style="color: #483d8b;">n</span><span style="color: #483d8b;">def</span> FF_LENGTH
<span style="color: #483d8b;">               #define</span> <span style="color: #a0522d;">FF_LENGTH</span> 0
<span style="color: #483d8b;">            #endif</span>
            <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i</span> = ppop();
            <span style="color: #a020f0;">if</span> (i &gt;= FF_LENGTH)
            {
               printf(<span style="color: #8b2252;">"no ff entry with index %i\n"</span>,i);
               BACKTRACE();
               handle_error(INTERNAL_ERROR_UNKNOWN_FF);
            }
            ppush((<span style="color: #228b22;">cell</span>)FF_Table[i]);
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_i:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_s:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">short</span>))ppop();
               <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s1</span> = (<span style="color: #228b22;">short</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(s1);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_b:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">char</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">char</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">b1</span> = (<span style="color: #228b22;">char</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(b1);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_bi:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">char</span>, <span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">char</span>,<span style="color: #228b22;">int</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">char</span> <span style="color: #a0522d;">b1</span> = (<span style="color: #228b22;">char</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(b1,i2);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_ib:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>, <span style="color: #228b22;">char</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>, <span style="color: #228b22;">char</span>))ppop();
               <span style="color: #228b22;">char</span> <span style="color: #a0522d;">b2</span> = (<span style="color: #228b22;">char</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,b2);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_is:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>))ppop();
               <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s2</span> = (<span style="color: #228b22;">short</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,s2);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_iis:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">short</span>))ppop();
               <span style="color: #228b22;">short</span> <span style="color: #a0522d;">s3</span> = (<span style="color: #228b22;">short</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2,s3);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_iii:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i3</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2,i3);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_ii:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">int</span>,<span style="color: #228b22;">int</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i2</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">i1</span> = (<span style="color: #228b22;">int</span>)ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun(i1,i2);
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_v:
            {
               <span style="color: #228b22;">int</span>(*<span style="color: #a0522d;">fun</span>)(<span style="color: #228b22;">void</span>) = (<span style="color: #228b22;">int</span> (*)(<span style="color: #228b22;">void</span>))ppop();
               <span style="color: #228b22;">int</span> <span style="color: #a0522d;">res</span> = fun();
               ppush((<span style="color: #228b22;">cell</span>)res);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> ccall_lit: <span style="color: #a020f0;">break</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">address is literal, nothing happens </span><span style="color: #b22222;">*/</span>
         <span style="color: #a020f0;">case</span> nop: <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> dref:
            x=(<span style="color: #228b22;">cell</span>)(*((<span style="color: #228b22;">short_jump_target</span>*) pc));
            ppush((<span style="color: #228b22;">cell</span>)memory+x);
            pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> bref:              <span style="color: #b22222;">/* </span><span style="color: #b22222;">reference to short-length in-memory data (type can be seen on-site)</span><span style="color: #b22222;">*/</span>
         <span style="color: #a020f0;">case</span> blitq:             <span style="color: #b22222;">/* </span><span style="color: #b22222;">deprecated </span><span style="color: #b22222;">*/</span>
            x=(<span style="color: #228b22;">cell</span>)(*((<span style="color: #228b22;">short_jump_target</span>*) pc));
            ppush((<span style="color: #228b22;">cell</span>) (BASE + ((<span style="color: #228b22;">short_jump_target</span>) x)));
            pc += <span style="color: #a020f0;">sizeof</span>(short_jump_target);
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> quit:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">quit the interpreter, returning 0 </span><span style="color: #b22222;">*/</span>
            printf(<span style="color: #8b2252;">"quitting interpreter!\n"</span>);
            <span style="color: #a020f0;">return</span> 0;
         <span style="color: #a020f0;">case</span> token: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">get one token from standard input </span><span style="color: #b22222;">*/</span>
            <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">tok</span> = read_token();
            <span style="color: #a020f0;">if</span> (tok) {
               ppush((<span style="color: #228b22;">cell</span>)tok);
            } <span style="color: #a020f0;">else</span> {
               print_error(<span style="color: #8b2252;">"token reader error"</span>);
               handle_error(INTERNAL_ERROR_TOKEN_READ);
            }} <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> lookup_name: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">provide a search start for the name (addr length) by using</span>
<span style="color: #b22222;">                               * the hash table lookup </span><span style="color: #b22222;">*/</span>
            <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">length</span> = ppop();
            <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">name</span> = ppop();
            ppush(lookup_ht_entry((<span style="color: #228b22;">uint8_t</span>) length,(<span style="color: #228b22;">char</span> *) name)); }
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> error:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">trigger internal error (bypasses any exception handling) </span><span style="color: #b22222;">*/</span>
            printf(<span style="color: #8b2252;">"error!\n"</span>);
            printf(<span style="color: #8b2252;">"\np"</span>);
            printstack(psp,pstack);
            printf(<span style="color: #8b2252;">"retain"</span>);
            printstack(retainsp,retainstack);
            printf(<span style="color: #8b2252;">"return"</span>);
            print_return_stack(returnsp,returnstack,(<span style="color: #228b22;">inst</span> *)BASE);
            BACKTRACE();
            handle_error(INTERNAL_ERROR_GENERAL);
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> tstart:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">start the timer </span><span style="color: #b22222;">*/</span>
            start_timer();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> tend:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">end the timer, return measurement results ( -- usecs secs ) </span><span style="color: #b22222;">*/</span>
            {
               <span style="color: #228b22;">unsigned</span> <span style="color: #228b22;">int</span> <span style="color: #a0522d;">sec</span>,<span style="color: #a0522d;">usec</span>;
               end_timer(&amp;sec,&amp;usec);
               ppush(usec);
               ppush(sec);
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> parsenum: {  <span style="color: #b22222;">/* </span><span style="color: #b22222;">parse the (c)string at the address on top of stack as number </span><span style="color: #b22222;">*/</span>
            <span style="color: #228b22;">char</span> *<span style="color: #a0522d;">str</span> = (<span style="color: #228b22;">char</span> *)ppop();
            <span style="color: #228b22;">cell</span> <span style="color: #a0522d;">num</span> = 0xa5a5a5a5;
            <span style="color: #228b22;">bool</span> <span style="color: #a0522d;">success</span>=parse_number(str+1,&amp;num);
            ppush(success ? num : (<span style="color: #228b22;">cell</span>) str);
            ppush((<span style="color: #228b22;">cell</span>)success);
         } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> tail:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">activate tail call elimination </span><span style="color: #b22222;">*/</span>
            tailcall=<span style="color: #008b8b;">true</span>; <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> notail:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">deactivate tail call elimination </span><span style="color: #b22222;">*/</span>
            tailcall=<span style="color: #008b8b;">false</span>; <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> reset:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">call externally refined system-reset </span><span style="color: #b22222;">*/</span>
            reset_system();
            <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">case</span> debug:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">activate debug mode </span><span style="color: #b22222;">*/</span>
            <span style="color: #a020f0;">if</span> (!debug_mode) {
               debug_mode=<span style="color: #008b8b;">true</span>;
            } <span style="color: #a020f0;">break</span>;
         <span style="color: #a020f0;">default</span>:
            printf(<span style="color: #8b2252;">"unimplemented instruction %#x\n"</span>,i);
            handle_error(INTERNAL_ERROR_INVALID_OPCODE);
      }
   <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">normal instructions skip the call execution paths </span><span style="color: #b22222;">*/</span>
   <span style="color: #008b8b;">nested_call</span>:  <span style="color: #b22222;">/* </span><span style="color: #b22222;">common execution path for non-tail calls </span><span style="color: #b22222;">*/</span>
      {
         <span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">next_word</span> = (<span style="color: #228b22;">inst</span> *) x;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">was set by the call instructions that jumped here </span><span style="color: #b22222;">*/</span>
         <span style="color: #228b22;">return_entry</span> <span style="color: #a0522d;">e</span> = {.return_address = pc, .current_call=next_word};
         returnpush(e);
         <span style="color: #a020f0;">if</span> (debug_mode) {
            <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">name</span> = find_by_address(next_word);
            debug_nest++;
            printf(<span style="color: #8b2252;">"calling: %s -&gt; %d\n"</span>,name,debug_nest);
         }
         pc=next_word;
      }
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;
   <span style="color: #008b8b;">tail_call</span>:    <span style="color: #b22222;">/* </span><span style="color: #b22222;">common execution path for tail calls </span><span style="color: #b22222;">*/</span>
      {
         <span style="color: #228b22;">inst</span> *<span style="color: #a0522d;">next_word</span> = (<span style="color: #228b22;">inst</span> *) x;  <span style="color: #b22222;">/* </span><span style="color: #b22222;">was set by the call instructions that jumped here </span><span style="color: #b22222;">*/</span>
         <span style="color: #a020f0;">if</span> (debug_mode) {
            <span style="color: #228b22;">char</span> * <span style="color: #a0522d;">name</span> = find_by_address(next_word);
            printf(<span style="color: #8b2252;">"tail calling: %s -&gt; %d\n"</span>,name,debug_nest);
         }
         pc = next_word;
      }
      <span style="color: #a020f0;">goto</span> <span style="color: #008b8b;">end_inst</span>;
   <span style="color: #008b8b;">end_inst</span>:     <span style="color: #b22222;">/* </span><span style="color: #b22222;">end of instruction processing </span><span style="color: #b22222;">*/</span>
      (<span style="color: #228b22;">void</span>) 0;
   }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2015-03-17 Di</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
