!-*- mode: factor -*-
USING: kernel math headers memory strings io exceptions ;
IN: sequences

SYMBOLS: unbox-error index-bounds-error ;

! access the second byte in the header (see headers.mfactor), which by default al sequence pointers point to
: element-size ( seq -- n ) 1 - getmem8 7 bitand 1 + ;
: element-type ( seq -- n ) 1 - getmem8 0xf8 bitand 3 asr ;
: length ( seq -- n ) getmem8 ;
: seq-size ( seq -- n ) [ element-size ] [ length ] bi * ;

! WARNING: <byte-array> has runtime allocation!
: <byte-array> ( n -- byte-array ) [ _strhead, ] keep _get-MP [ [ 0xa5 b, ] times ] dip 1 - ;
! random access into byte-array or string, seq is assumed to point to the count byte of the sequence, and one byte before that the element size
: _ba-assert-index ( n seq -- n seq ) [ strlen 0 swap in-range not [ "byte-array index out of bound" print error ] when ] 2keep ;
: ba-nth ( n seq -- elt ) _ba-assert-index + 1 + getmem8 ;
: ba-set-nth ( elt n seq -- ) _ba-assert-index + 1 + setmem8 ;
! specialized version of each for byte arrays and strings
: _ba-each-step ( ... addr quot: ( ... x -- ... ) -- ... addr+1 quot ) [ [ getmem8 ] dip call ] 2keep [ 1 + ] dip ;
: ba-each ( ... seq quot: ( ... x -- ... ) -- ... ) [ uncount ] dip swap [ _ba-each-step ] times 2drop ;
: ba-reduce ( ... seq identity quot: ( ... prev elt -- ... next ) -- ... result ) [ swap ] dip ba-each ;
: ba-find ( ... seq quot: ( ... elt -- ... ? ) -- ... i elt ? ) over strlen [ pick pick [ swap [ swap ba-nth ] dip call ] 2dip rot ] find-integer [ nip swap over swap ba-nth t ] [ 2nip f f ] if ;
: ba-change-nth ( ..a i seq quot: ( ..a elt -- ..b newelt ) -- ..b )
    [ [ ba-nth ] dip call ] 3keep drop ba-set-nth ; inline

: ia-length ( ia -- n ) strlen ;
: _ia-assert-index ( n seq -- n seq ) [ ia-length 0 swap in-range not [ "int-array index out of bound" print error ] when ] 2keep ;
: ia-nth ( n seq -- elt ) _ia-assert-index 1 + swap 4 * + getmem ;
: ia-set-nth ( elt n seq -- ) _ia-assert-index 1 + swap 4 * + setmem ;
: _ia-each-step ( ... addr quot: ( ... x -- ... ) -- ... addr+4 quot ) 2dup [ [ getmem ] dip call ] 2dip [ 4 + ] dip ;
: ia-each ( ... seq quot: ( ... x -- ... ) -- ... ) [ uncount ] dip swap [ _ia-each-step ] times 2drop ;

! known bad
! : each ( ... seq quot: ( ... x -- ... ) -- ... )
!     over [ 1 + ] 2dip
!     getmem8 [ dup 0 = [ ba-each ]
!               [ 2 = [ ia-each ]
!                 [ "each: unknown sequence type: " print '0' + emit error ] if ] if ] if ;

! return address of nth element without checking for size
: _nth-address-unsafe ( n seq -- elt-address )
    swap
    over element-size
    * + 1 + ;

! boxed data is 5 bytes long, (see headers, type 4)
: _unbox-data ( boxed-data-addr -- data )
    [ 1 + ] [ getmem8 ] bi      ! ( address type )
    { { 0 [ getmem ] }
      { 2 [ resolve-bref ] }
      { 3 [ resolve-aref ] }
      [ drop unbox-error throw ] } case ;

: _assert-nth-index-range ( n seq -- n seq )
    [ length 0 swap in-range [ index-bounds-error throw ] unless ] 2keep ;

: nth ( n seq -- elt )
    _assert-nth-index-range
    [ _nth-address-unsafe ] keep
    [ element-size ] [ element-type ] bi
    dup 0 = [ drop 1 = [ getmem8 ] [ getmem ] if ]
    [ dup 1 = [ 2drop getmem ]
      [ dup 2 = [ 2drop resolve-bref ]
        [ dup 3 = [ 2drop resolve-aref ]
          [ dup 4 = [ 2drop unbox-data ]
            [ "unknown element type: " print pwrite "size: " pwrite error ] if ] if ] if ] if ] if ;

: each ( ... seq quot: ( ..a x -- ..b ) -- ... )
    swap dup length             ! quot seq len
    [                           ! quot seq i
      2over                     ! quot seq i quot seq
      [ swap nth swap call ] 2dip ] each-integer
    2drop ; inline
